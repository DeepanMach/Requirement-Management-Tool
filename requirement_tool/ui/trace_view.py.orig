"""Traceability matrix view used by the main window."""
from __future__ import annotations

from typing import Callable, Iterable, List, Optional, Sequence

import logging

import pandas as pd
from PyQt6.QtCore import QPoint, Qt
from PyQt6.QtGui import QFont
from PyQt6.QtWidgets import (
    QAbstractItemView,
    QFileDialog,
    QLabel,
    QMessageBox,
    QPushButton,
    QSizePolicy,
    QTableWidget,
    QTableWidgetItem,
    QHBoxLayout,
    QVBoxLayout,
    QWidget,
)

LOGGER = logging.getLogger(__name__)


class TraceMatrixView(QWidget):
    """Widget to display traceability matrices."""

    def __init__(self, parent: QWidget | None = None):
        super().__init__(parent)
        self._df = pd.DataFrame()
        self.current_rows: List[Sequence[str]] = []
        self.current_cols: List[str] = []
        self.active_filters: dict[str, set[str]] = {}
        self.current_row_indices: List[int] = []
        self._filtered_row_indices: List[int] = []
        self._link_columns: set[int] = set()
        self.current_sources: List[str] = []
        self._filtered_row_sources: List[str] = []
        self._row_tooltips: List[str] = []
        self._filtered_row_tooltips: List[str] = []
        self.navigate_to_requirement: Optional[Callable[[str, Optional[str]], None]] = None
        self._row_index_column: Optional[str] = None

        layout = QVBoxLayout(self)
        self.info_label = QLabel(
            "Traceability Matrix (Forward/Backward). Use header clicks to filter."
        )
        layout.addWidget(self.info_label)

        button_row = QHBoxLayout()
        self.btn_forward = QPushButton("Forward Trace")
        self.btn_forward.clicked.connect(self.show_forward_trace)
        self.btn_backward = QPushButton("Backward Trace")
        self.btn_backward.clicked.connect(self.show_backward_trace)
        self.btn_save = QPushButton("Save to Excel")
        self.btn_save.clicked.connect(self.save_current_view)
        button_row.addWidget(self.btn_forward)
        button_row.addWidget(self.btn_backward)
        button_row.addStretch()
        button_row.addWidget(self.btn_save)
        layout.addLayout(button_row)

        self.table = QTableWidget()
        self.table.setSizePolicy(
            QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding
        )
        self.table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.table.horizontalHeader().setSectionsClickable(True)
        self.table.horizontalHeader().sectionClicked.connect(self._on_header_clicked)
        self.table.cellActivated.connect(self._on_cell_triggered)
        self.table.cellClicked.connect(self._on_cell_triggered)
        layout.addWidget(self.table)

    # ------------------------------------------------------------------
    def load_data(self, df: pd.DataFrame) -> None:
        if df is None or df.empty:
            self._df = pd.DataFrame()
            self._clear_table("No data loaded.")
            return

        # Copy original dataframe but filter only requirement rows
        self._df = df.copy()

        # Detect requirement ID column dynamically
        req_col = None
        for cand in ["requirement id", "req id", "reqid"]:
            for col in self._df.columns:
                if cand in col.lower():
                    req_col = col
                    break
            if req_col:
                break

        # Filter rows where Requirement ID is non-empty
        if req_col:
            before_count = len(self._df)
            self._df = self._df[self._df[req_col].notna() & (self._df[req_col].astype(str).str.strip() != "")]
            after_count = len(self._df)
            LOGGER.info(f"Filtered requirement rows: {before_count - after_count} empty rows removed.")
        else:
            LOGGER.warning("No Requirement ID column detected for filtering.")

        self.active_filters.clear()
        self._row_index_column = None
        self._row_tooltips = []
        self._filtered_row_tooltips = []

        # Detect row index column if present
        for candidate in ("_row_index", "__row_index__", "RowIndex"):
            if candidate in self._df.columns:
                self._row_index_column = candidate
                break

        # Proceed to render
        self.show_forward_trace()


    # ------------------------------------------------------------------
    def show_forward_trace(self) -> None:
        if self._df.empty:
            self._clear_table("No data loaded.")
            return

        req_col = self._detect_column(["requirement id", "req id", "reqid"])
        up_col = self._detect_column(["up trace", "uptrace"])
        if req_col is None or up_col is None:
            self._clear_table("Required columns not found for forward trace.")
            return

        cols = [req_col, up_col]
        rows: List[Sequence[str]] = []
        indices: List[int] = []
        sources: List[str] = []
        tooltips: List[str] = []
        for i in range(len(self._df)):
            source_index = self._df.index[i]
            source_value = (
                str(self._df.at[source_index, "SourceFile"])
                if "SourceFile" in self._df.columns
                else ""
            )
            req_value = (
                str(self._df.at[source_index, req_col])
                if req_col in self._df.columns
                else ""
            )
            up_value = (
                str(self._df.at[source_index, up_col])
                if up_col in self._df.columns
                else ""
            )
            rows.append((req_value, up_value))
            indices.append(self._extract_row_index(i))
            source_type = (
                str(self._df.at[source_index, "SourceType"]).strip().lower()
                if "SourceType" in self._df.columns
                else ""
            )
            normalized_source = (
                "Excel" if source_type == "excel" else (source_value or "Manual")
            )
            sources.append(normalized_source or "Manual")

            tooltip_text = ""
            if "Object Text" in self._df.columns:
                text_value = self._df.at[source_index, "Object Text"]
                if not pd.isna(text_value):
                    tooltip_text = str(text_value).strip()
            tooltips.append(tooltip_text)

        self._update_table(cols, rows, "Forward Trace", indices, sources, tooltips)

    # ------------------------------------------------------------------
    def show_backward_trace(self) -> None:
        if self._df.empty:
            self._clear_table("No data loaded.")
            return

        up_col = self._detect_column(["up trace", "uptrace"])
        req_col = self._detect_column(["requirement id", "req id", "reqid"])
        if req_col is None or up_col is None:
            self._clear_table("Required columns not found for backward trace.")
            return

        cols = [up_col, req_col]
        rows: List[Sequence[str]] = []
        indices: List[int] = []
        sources: List[str] = []
        tooltips: List[str] = []
        for i in range(len(self._df)):
            source_index = self._df.index[i]
            source_value = (
                str(self._df.at[source_index, "SourceFile"])
                if "SourceFile" in self._df.columns
                else ""
            )
            up_value = (
                str(self._df.at[source_index, up_col])
                if up_col in self._df.columns
                else ""
            )
            req_value = (
                str(self._df.at[source_index, req_col])
                if req_col in self._df.columns
                else ""
            )
            rows.append((up_value, req_value))
            indices.append(self._extract_row_index(i))
            source_type = (
                str(self._df.at[source_index, "SourceType"]).strip().lower()
                if "SourceType" in self._df.columns
                else ""
            )
            normalized_source = (
                "Excel" if source_type == "excel" else (source_value or "Manual")
            )
            sources.append(normalized_source or "Manual")
            tooltip_text = ""
            if "Object Text" in self._df.columns:
                text_value = self._df.at[source_index, "Object Text"]
                if not pd.isna(text_value):
                    tooltip_text = str(text_value).strip()
            tooltips.append(tooltip_text)
        self._update_table(cols, rows, "Backward Trace", indices, sources, tooltips)

    # ------------------------------------------------------------------
    def _detect_column(self, candidates: Iterable[str]) -> str | None:
        lower_map = {c.lower(): c for c in self._df.columns}
        for cand in candidates:
            if cand in lower_map:
                return lower_map[cand]
        for column in self._df.columns:
            if any(part in column.lower() for part in candidates):
                return column
        return None

    # ------------------------------------------------------------------
    def _update_table(
        self,
        columns: Sequence[str],
        rows: Sequence[Sequence[str]],
        mode: str,
        row_indices: Sequence[int] | None = None,
        row_sources: Sequence[str] | None = None,
        row_tooltips: Sequence[str] | None = None,
    ) -> None:
        self.current_cols = list(columns)
        self.current_rows = [tuple(str(v) for v in row) for row in rows]
        if row_indices is None:
            self.current_row_indices = list(range(len(self.current_rows)))
        else:
            self.current_row_indices = list(row_indices)
        if row_sources is None:
            self.current_sources = [""] * len(self.current_rows)
        else:
            self.current_sources = list(row_sources)
        if row_tooltips is None:
            self._row_tooltips = [""] * len(self.current_rows)
        else:
            self._row_tooltips = list(row_tooltips)
        self._link_columns = {
            idx
            for idx, name in enumerate(self.current_cols)
            if self._is_link_column(name)
        }
        self.info_label.setText(f"Traceability Matrix ({mode})")
        self._populate_table_from_current()

    # ------------------------------------------------------------------
    def _clear_table(self, message: str) -> None:
        self.table.clear()
        self.table.setRowCount(0)
        self.table.setColumnCount(0)
        self.info_label.setText(message)
        self._filtered_row_indices = []
        self._filtered_row_sources = []
        self.current_sources = []
        self._row_tooltips = []
        self._filtered_row_tooltips = []

    # ------------------------------------------------------------------
    def _populate_table_from_current(self) -> None:
        rows = self.current_rows
        cols = self.current_cols
        indices = self.current_row_indices
        sources = self.current_sources
        tooltips = self._row_tooltips
        if self.active_filters:
            filtered_rows: List[Sequence[str]] = []
            filtered_indices: List[int] = []
            filtered_sources: List[str] = []
            filtered_tooltips: List[str] = []
            for row, idx, source, tooltip in zip(rows, indices, sources, tooltips):
                include = True
                for col_idx, column in enumerate(cols):
                    selected = self.active_filters.get(column)
                    if selected and row[col_idx] not in selected:
                        include = False
                        break
                if include:
                    filtered_rows.append(row)
                    filtered_indices.append(idx)
                    filtered_sources.append(source)
                    filtered_tooltips.append(tooltip)
            rows = filtered_rows
            indices = filtered_indices
            sources = filtered_sources
            tooltips = filtered_tooltips
        self._filtered_row_indices = list(indices)
        self._filtered_row_sources = list(sources)
        self._filtered_row_tooltips = list(tooltips)

        self.table.clear()
        self.table.setColumnCount(len(cols))
        self.table.setRowCount(len(rows))
        self.table.setHorizontalHeaderLabels(cols)

        for i, row in enumerate(rows):
            tooltip = tooltips[i] if i < len(tooltips) else ""
            for j, value in enumerate(row):
                item = QTableWidgetItem(str(value))
                item.setFlags(item.flags() & ~Qt.ItemFlag.ItemIsEditable)
                if j in self._link_columns and str(value).strip():
                    font = QFont(item.font())
                    font.setUnderline(True)
                    item.setFont(font)
                    item.setForeground(Qt.GlobalColor.blue)
                if tooltip:
                    item.setToolTip(tooltip)
                self.table.setItem(i, j, item)

        self.table.resizeColumnsToContents()

    # ------------------------------------------------------------------
    def highlight_requirement(self, requirement: str) -> bool:
        target = (requirement or "").strip().lower()
        if not target:
            return False
        for row in range(self.table.rowCount()):
            for col in self._link_columns:
                item = self.table.item(row, col)
                if item and item.text().strip().lower() == target:
                    self.table.selectRow(row)
                    self.table.scrollToItem(
                        item, QAbstractItemView.ScrollHint.PositionAtCenter
                    )
                    return True
        return False

    # ------------------------------------------------------------------
    def _is_link_column(self, name: str) -> bool:
        lowered = name.strip().lower()
        return lowered in {
            "requirement id",
            "req id",
            "reqid",
            "up trace",
            "uptrace",
        }

    # ------------------------------------------------------------------
    def _extract_row_index(self, position: int) -> int:
        if (
            self._row_index_column
            and self._row_index_column in self._df.columns
            and not self._df.empty
        ):
            source_index = self._df.index[position]
            value = self._df.at[source_index, self._row_index_column]
            try:
                return int(value)
            except (TypeError, ValueError):
                try:
                    return int(float(value))
                except (TypeError, ValueError):
                    return int(position)
        return int(position)

    # ------------------------------------------------------------------
    def _on_cell_triggered(self, row: int, column: int) -> None:
        if column < 0 or column >= len(self.current_cols):
            return
        if column not in self._link_columns:
            return
        if row < 0 or row >= len(self._filtered_row_indices):
            return
        item = self.table.item(row, column)
        if item is None:
            return
        target = item.text().strip()
        if not target:
            return
        handler = self.navigate_to_requirement
        if handler:
            source = ""
            if row < len(self._filtered_row_sources):
                source = self._filtered_row_sources[row]
            handler(target, source)

    # ------------------------------------------------------------------
    def _on_header_clicked(self, index: int) -> None:
        if index < 0 or index >= len(self.current_cols):
            return

        column = self.current_cols[index]
        values = sorted({row[index] for row in self.current_rows})

        from PyQt6.QtWidgets import (
            QCheckBox,
            QLineEdit,
            QMenu,
            QPushButton,
            QScrollArea,
            QVBoxLayout,
            QWidget,
            QWidgetAction,
        )

        menu = QMenu(self)
        search = QLineEdit()
        search.setPlaceholderText("Search...")
        act_search = QWidgetAction(menu)
        act_search.setDefaultWidget(search)
        menu.addAction(act_search)
        menu.addSeparator()

        scroll = QScrollArea()
        scroll.setMinimumWidth(320)
        scroll.setMaximumHeight(380)
        scroll.setWidgetResizable(True)

        container = QWidget()
        vbox = QVBoxLayout(container)
        vbox.setContentsMargins(6, 6, 6, 6)
        vbox.setSpacing(4)

        checkboxes: List[QCheckBox] = []
        selected_values = self.active_filters.get(column, set(values))
        for value in values:
            checkbox = QCheckBox(value)
            checkbox.setChecked(value in selected_values)
            vbox.addWidget(checkbox)
            checkboxes.append(checkbox)

        scroll.setWidget(container)
        act_scroll = QWidgetAction(menu)
        act_scroll.setDefaultWidget(scroll)
        menu.addAction(act_scroll)
        menu.addSeparator()

        apply_button = QPushButton("Apply")
        act_apply = QWidgetAction(menu)
        act_apply.setDefaultWidget(apply_button)
        menu.addAction(act_apply)
        clear_action = menu.addAction("Clear Filter")
        show_all_action = menu.addAction("Show All")

        def on_search(text: str) -> None:
            lower_text = text.lower()
            for checkbox in checkboxes:
                checkbox.setVisible(lower_text in checkbox.text().lower())

        search.textChanged.connect(on_search)

        def on_apply() -> None:
            selected = {cb.text() for cb in checkboxes if cb.isChecked()}
            if len(selected) == len(checkboxes):
                self.active_filters.pop(column, None)
            else:
                self.active_filters[column] = selected
            self._populate_table_from_current()
            menu.close()

        apply_button.clicked.connect(on_apply)

        def on_clear() -> None:
            self.active_filters.pop(column, None)
            self._populate_table_from_current()
            menu.close()

        clear_action.triggered.connect(on_clear)

        def on_show_all() -> None:
            self.active_filters.clear()
            self._populate_table_from_current()
            menu.close()

        show_all_action.triggered.connect(on_show_all)

        header = self.table.horizontalHeader()
        x = header.sectionPosition(index)
        y = header.height()
        menu.exec(self.table.mapToGlobal(QPoint(x + 12, y + 20)))

    # ------------------------------------------------------------------
    

    # ------------------------------------------------------------------
    def load_pairs(self, columns, rows, row_sources=None) -> None:
        """
        Load a pre-built pairs table (cross-artifact) into the view.
        `columns`: ["From Artifact","From ID","↔","To Artifact","To ID"]
        `rows`: list of tuples of same length
        `row_sources`: preferred navigation tab labels (optional)
        """
        self._df = pd.DataFrame()  # not used in pair mode
        self.active_filters.clear()
        self._row_index_column = None
        if row_sources is None:
            row_sources = [""] * len(rows)
        tooltips = [""] * len(rows)
        self._update_table(columns, rows, "Cross Pairs", row_indices=list(range(len(rows))), row_sources=row_sources, row_tooltips=tooltips)
    def save_current_view(self) -> None:
        if not self.current_rows or not self.current_cols:
            QMessageBox.information(self, "Nothing", "No trace data to save.")
            return

        file_name, _ = QFileDialog.getSaveFileName(
            self, "Save Trace to Excel", "", "Excel Files (*.xlsx)"
        )
        if not file_name:
            return

        if not file_name.lower().endswith(".xlsx"):
            file_name += ".xlsx"

        try:
            pd.DataFrame(self.current_rows, columns=self.current_cols).to_excel(
                file_name, index=False
            )
        except Exception as exc:  # pragma: no cover - relies on pandas IO
            LOGGER.exception("Failed to save trace view")
            QMessageBox.critical(self, "Save Error", str(exc))
        else:
            QMessageBox.information(self, "Saved", f"Trace saved to {file_name}")
            parent = self.parent()
            if parent and hasattr(parent, "log_console"):
                parent.log_console(f"Trace saved to {file_name}")
