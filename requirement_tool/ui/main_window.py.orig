"""Main window for the requirement management tool."""
from __future__ import annotations
from functools import partial
import base64
import binascii
import copy
import html
import re
import io
import json
import os, shutil
import logging
import mimetypes
from pathlib import Path
from typing import Dict, Optional, Sequence
import time
import datetime
import pandas as pd
from PyQt6.QtCore import Qt, QTimer, QPoint
from PyQt6.QtGui import QImage, QKeySequence, QPixmap, QShortcut, QTextCursor, QTextDocument, QTextCharFormat, QColor
from PyQt6.QtWidgets import (
    QApplication,
    QFileDialog,
    QDialog,
    QDialogButtonBox,
    QComboBox,
    QDoubleSpinBox,
    QFormLayout,
    QHBoxLayout,
    QHeaderView,
    QLineEdit,
    QInputDialog,
    QMainWindow,
    QMenu,
    QMessageBox,
    QPlainTextEdit,
    QPushButton,
    QLabel,
    QSpinBox,
    QSizePolicy,
    QStackedWidget,
    QTabWidget,
    QTableWidget,
    QTableWidgetItem,
    QTextBrowser,
    QTreeWidget,
    QTreeWidgetItem,
    QVBoxLayout,
    QWidget,
    QWidgetAction,
    QCheckBox,
    QScrollArea,
    QListWidget,
    QListWidgetItem,
    QTextEdit,
    QAbstractItemView,
    QProgressDialog,
    QProgressBar,
)
from Excel_preview_ui import (
    # Map old names to the new helpers
    renumber_headings as renumber_headings_and_requirements,
    renumber_captions as renumber_figures_and_tables,
    is_image_marker,
    is_table_marker,
    parse_image_marker,
    load_table_payload,
    detect_markdown_table,
    save_table_payload,
)

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QTableView, QTextBrowser,
    QFileDialog, QAbstractItemView, QHeaderView, QMenu, QLineEdit,
    QScrollArea, QCheckBox, QWidgetAction, QPushButton
)
from PyQt6.QtGui import QStandardItemModel, QStandardItem, QPixmap
from PyQt6.QtCore import Qt
import os
import base64

from ..data_manager import (
    OPTIONAL_METADATA_COLUMNS,
    REQUIRED_COLUMNS,
    RequirementDataError,
    RequirementDataManager,
)
from .trace_view import TraceMatrixView

from pathlib import Path

def canonical_projects_root(file_path: str | Path) -> Path:
    """
    Always return the OUTER `<.../Requirement-Management-Tool>/projects` folder,
    even if this file lives under the inner `<.../Requirement-Management-Tool/Requirement-Management-Tool/...>`.
    """
    here = Path(file_path).resolve()
    outer = None
    for p in here.parents:
        if p.name == "Requirement-Management-Tool":
            outer = p  # this will end up the *highest* one
    if outer is None:
        # Fallback if the folder name is different on your machine
        outer = here.parents[2]
    root = (outer / "projects").resolve()
    root.mkdir(parents=True, exist_ok=True)
    return root

def both_project_dirs(project_name: str, file_path: str | Path) -> list[Path]:
    """Return [canonical, legacy] project folders (legacy only if it exists)."""
    canon = canonical_projects_root(file_path) / project_name
    legacy = (canonical_projects_root(file_path).parent / "Requirement-Management-Tool" / "projects" / project_name)
    return [canon, legacy]

class TabSelectionDialog(QDialog):
    
    def __init__(self, open_tabs: list[tuple[str, str]], parent=None):
        super().__init__(parent)
        self.setWindowTitle("Select tabs for Traceability Matrix")
        self.setMinimumWidth(420)
        self.setMinimumHeight(250)  # ensures enough space for list + buttons

        # --- List Widget ---
        self.list = QListWidget(self)
        self.list.setSelectionMode(QAbstractItemView.SelectionMode.MultiSelection)
        for tab_id, label in open_tabs:
            item = QListWidgetItem(label)
            item.setData(Qt.ItemDataRole.UserRole, tab_id)
            self.list.addItem(item)

        # --- Dialog Buttons ---
        btns = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel,
            parent=self
        )
        btns.accepted.connect(self.accept)
        btns.rejected.connect(self.reject)

        # --- Layout ---
        layout = QVBoxLayout(self)
        layout.addWidget(self.list)
        layout.addWidget(btns)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)

        # Optional: improve scaling for Windows 11
        self.setSizeGripEnabled(True)

    def selected_tab_ids(self) -> list[str]:
        return [i.data(Qt.ItemDataRole.UserRole) for i in self.list.selectedItems()]


class ReorderFilesDialog(QDialog):
    """Simple list-with-up/down to reorder files before import."""
    def __init__(self, paths: Sequence[str], parent: QWidget | None = None, title: str = "Reorder Excel Files"):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.setMinimumWidth(520)

        self.list = QListWidget(self)
        for p in paths:
            item = QListWidgetItem(Path(p).name)
            item.setToolTip(p)
            item.setData(Qt.ItemDataRole.UserRole, p)
            self.list.addItem(item)
        self.list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)

        btn_up = QPushButton("Move Up")
        btn_dn = QPushButton("Move Down")
        btn_rm = QPushButton("Remove")
        btn_up.clicked.connect(self._move_up)
        btn_dn.clicked.connect(self._move_down)
        btn_rm.clicked.connect(self._remove_item)

        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel, parent=self)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)

        left = QVBoxLayout()
        left.addWidget(QLabel("Order (top to bottom):"))
        left.addWidget(self.list, 1)

        right = QVBoxLayout()
        right.addWidget(btn_up)
        right.addWidget(btn_dn)
        right.addSpacing(8)
        right.addWidget(btn_rm)
        right.addStretch(1)

        row = QHBoxLayout()
        row.addLayout(left, 1)
        row.addLayout(right)

        root = QVBoxLayout(self)
        root.addLayout(row, 1)
        root.addWidget(buttons)

    def _move_up(self):
        r = self.list.currentRow()
        if r > 0:
            item = self.list.takeItem(r)
            self.list.insertItem(r - 1, item)
            self.list.setCurrentRow(r - 1)

    def _move_down(self):
        r = self.list.currentRow()
        if 0 <= r < self.list.count() - 1:
            item = self.list.takeItem(r)
            self.list.insertItem(r + 1, item)
            self.list.setCurrentRow(r + 1)

    def _remove_item(self):
        r = self.list.currentRow()
        if r >= 0:
            self.list.takeItem(r)

    def ordered_paths(self) -> list[str]:
        out: list[str] = []
        for i in range(self.list.count()):
            item = self.list.item(i)
            if item:
                out.append(str(item.data(Qt.ItemDataRole.UserRole)))
        return out


LOGGER = logging.getLogger(__name__)


ASSETS_DIR = (Path(__file__).resolve().parent / "assets")
ASSETS_DIR.mkdir(exist_ok=True)
DEFAULT_HOWELL_LOGO = str(ASSETS_DIR / "howell_logo.png")
DEFAULT_MACH_LOGO = str(ASSETS_DIR / "mach_logo.png")

# Simple project cache in the user's home dir
PROJECT_STORE_DIR = Path.home() / ".mach_reqmgr"
PROJECT_STORE_DIR.mkdir(exist_ok=True)
PROJECT_STORE_PATH = PROJECT_STORE_DIR / "projects.json"


class RequirementPatternDialog(QDialog):
    """Dialog to capture requirement ID extraction preferences."""

    def __init__(self, parent: QWidget | None, initial: Optional[dict[str, str]] = None):
        super().__init__(parent)
        self.setWindowTitle("Requirement ID Pattern")
        initial = initial or {}
        mode = initial.get("mode", "prefixes")
        value = initial.get("value", "")

        layout = QVBoxLayout(self)
        form = QFormLayout()
        layout.addLayout(form)

        self.mode_combo = QComboBox(self)
        self.mode_combo.addItem("Prefixes (comma-separated)", "prefixes")
        self.mode_combo.addItem("Custom Regular Expression", "regex")
        index = self.mode_combo.findData(mode)
        if index >= 0:
            self.mode_combo.setCurrentIndex(index)

        self.value_edit = QLineEdit(value, self)
        self._update_placeholder()
        self.mode_combo.currentIndexChanged.connect(self._update_placeholder)

        form.addRow("Pattern Type", self.mode_combo)
        form.addRow("Pattern Value", self.value_edit)

        self.help_label = QLabel(
            "Prefixes example: REQ, SWR\n"
            "Regex example: ^\\s*(?P<id>REQ\\d+)\\s*[:\\-]\\s*(?P<body>.+)$",
            self,
        )
        self.help_label.setWordWrap(True)
        layout.addWidget(self.help_label)

        buttons = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel,
            parent=self,
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

    def _update_placeholder(self) -> None:
        mode = self.mode_combo.currentData()
        if mode == "regex":
            self.value_edit.setPlaceholderText("Enter custom regular expression")
        else:
            self.value_edit.setPlaceholderText("e.g. REQ, SWR, SYS")

    def result_config(self) -> dict[str, str]:
        return {
            "mode": str(self.mode_combo.currentData()),
            "value": self.value_edit.text().strip(),
        }


    def _save_project_metadata(self, excel_files=None, word_files=None, word_pattern=None):
        """Merge and save project.json with provided fields."""
        try:
            data = {}
            if hasattr(self, "project_meta"):
                if self.project_meta.exists():
                    with self.project_meta.open("r", encoding="utf-8") as f:
                        try:
                            data = json.load(f)
                        except Exception:
                            data = {}
            else:
                return
            data["name"] = getattr(self, "project_name", None)
            data["last_modified"] = datetime.datetime.now().isoformat()
            if excel_files is not None:
                data["excel_files"] = excel_files
            if word_files is not None:
                data["word_files"] = word_files
            if word_pattern is not None:
                data["word_pattern"] = word_pattern
            with self.project_meta.open("w", encoding="utf-8") as f:
                json.dump(data, f, indent=4)
        except Exception as e:
            if hasattr(self, "log_console"):
                self.log_console(f"Metadata save error: {e}")


class LoadingDialog(QDialog):
        """Simple modal popup shown while restoring heavy project data."""
        def __init__(self, text="Loading...", parent=None):
            super().__init__(parent)
            self.setWindowTitle("Please Wait")
            self.setModal(True)
            self.setFixedSize(360, 120)
            layout = QVBoxLayout(self)
            label = QLabel(text)
            label.setStyleSheet("font-weight:600; font-size:14px;")
            label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            bar = QProgressBar()
            bar.setRange(0, 0)  # indefinite animation
            layout.addWidget(label)
            layout.addWidget(bar)

# >>> ADD: a self-contained Excel tab that shows an editable table + can build HTML preview
class ExcelTab(QWidget):
    """
    Lightweight, embedded Excel preview/editor tab.
    - Shows a QTableView with images and table markers displayed meaningfully.
    - Holds a pandas DataFrame in self.df (editable via cell edits).
    - Can build HTML preview using the same logic as your standalone preview.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.df = None

        lay = QVBoxLayout(self)
        self.table = QTableView(self)
        self.table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.table.verticalHeader().setDefaultSectionSize(56)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Interactive)
        self.table.horizontalHeader().setStretchLastSection(True)

        # Optional: context/filter menu (like your standalone). Keep minimal here.
        self.table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self._open_context_menu)

        lay.addWidget(self.table)

        self._columns = []
        self._model = QStandardItemModel(0, 0)
        self.table.setModel(self._model)

    # ------ Loading files into a single DF ------
    def load_files(self, files: list[str]) -> None:
        """
        Read all sheets from each Excel file, normalize columns, detect markdown tables,
        then apply renumbering using the updated Excel_preview_ui helpers.
        """
        import pandas as pd
        from pathlib import Path

        frames = []
        logs = []
        for fpath in files or []:
            try:
                xls = pd.ExcelFile(fpath, engine="openpyxl")
            except Exception as e:
                logs.append(f"❌ Failed to open {Path(fpath).name}: {e}")
                continue

            for sheet in xls.sheet_names:
                try:
                    df = pd.read_excel(fpath, sheet_name=sheet, dtype=str, engine="openpyxl").fillna("")
                except Exception as e:
                    logs.append(f"⚠️ Failed reading sheet {sheet} in {Path(fpath).name}: {e}")
                    continue

                # Ensure base columns exist
                if "Object Type" not in df.columns:
                    df.insert(0, "Object Type", "")
                if "Object Text" not in df.columns:
                    df.insert(1, "Object Text", "")

                # Convert markdown tables to payload markers so previews render nicely
                for col in df.columns:
                    for i in range(len(df)):
                        cell = str(df.at[i, col])
                        md = detect_markdown_table(cell)
                        if md:
                            rows, cols, data, _has_header = md
                            df.at[i, col] = save_table_payload(rows, cols, data, name="")

                df["SourceFile"] = Path(fpath).name
                df["SheetName"]  = sheet
                frames.append(df)

        if not frames:
            # Keep empty model if nothing loaded
            self.df = pd.DataFrame()
            self._model = QStandardItemModel(0, 0)
            self.table.setModel(self._model)
            return

        combined = pd.concat(frames, ignore_index=True).reset_index(drop=True)

        # Apply updated numbering functions (mapped imports)
        combined = renumber_headings_and_requirements(combined)
        combined = renumber_figures_and_tables(combined)

        self.df = combined.reset_index(drop=True)
        self._populate_table()


    # ------ Build HTML (for MainWindow’s preview) ------
    def build_preview_html(self) -> str:
        if self.df is None or self.df.empty:
            return "<div style='font-family:Segoe UI;'>[No data loaded]</div>"

        df = self.df
        cols = list(df.columns)
        parts = ['<div style="font-family:Segoe UI, sans-serif;color:#000;">']

        # small helper
        def heading_level(ot: str) -> int:
            txt = (ot or "").strip().lower()
            for k, lvl in {
                "heading 1":1,"heading1":1,"h1":1,"heading":1,"title":1,
                "heading 2":2,"heading2":2,"h2":2,
                "heading 3":3,"heading3":3,"h3":3,
                "heading 4":4,"heading4":4,"h4":4,
                "heading 5":5,"heading5":5,"h5":5,
                "heading 6":6,"heading6":6,"h6":6,
            }.items():
                if txt == k:
                    return lvl
            return 0

        for _, row in df.iterrows():
            objtype = str(row.get("Object Type", "")).strip()
            text = str(row.get("Object Text", "")).strip()
            lvl = heading_level(objtype)
            if 1 <= lvl <= 6:
                tag = {1:'h1',2:'h2',3:'h3',4:'h4',5:'h5',6:'h6'}[lvl]
                parts.append(f"<{tag} style='margin:6px 0 4px 0;'>{text}</{tag}>")
                continue

            rendered_any = False
            for c in cols:
                val = row.get(c, "")
                if is_image_marker(val):
                    meta = parse_image_marker(val)
                    pth = meta.get("path", "")
                    if pth and os.path.exists(pth):
                        with open(pth, "rb") as fh:
                            b64 = base64.b64encode(fh.read()).decode("ascii")
                        parts.append(f"<div style='text-align:center;margin:8px;'><img src='data:image/png;base64,{b64}' style='max-width:80%;height:auto;border:0;'></div>")
                    else:
                        parts.append(f"<p style='color:#a00'>[Missing Image: {os.path.basename(pth)}]</p>")
                    rendered_any = True
                elif is_table_marker(val):
                    r, cnum, data, name = load_table_payload(val)
                    html = ["<table border='1' cellspacing='0' cellpadding='6' style='border-collapse:collapse;margin:8px auto;'>"]
                    for i in range(max(1, r)):
                        html.append("<tr>")
                        for j in range(max(1, cnum)):
                            try:
                                cell = str(data[i][j])
                            except Exception:
                                cell = ""
                            tag2 = "th" if i == 0 and any(data[0]) else "td"
                            style = "font-weight:bold;" if tag2 == "th" else ""
                            html.append(f"<{tag2} style='{style}'>{cell}</{tag2}>")
                        html.append("</tr>")
                    html.append("</table>")
                    parts.append("".join(html))
                    rendered_any = True

            if not rendered_any and text:
                parts.append(f"<div>{self._text_to_html_blocks(text)}</div>")

        parts.append("</div>")
        return "".join(parts)

    # ------ Internal: populate table view from self.df ------
    def _populate_table(self):
        df = self.df
        self._columns = list(df.columns)
        self._model = QStandardItemModel(len(df), len(self._columns))
        self._model.setHorizontalHeaderLabels(self._columns)
        self.table.setModel(self._model)

        for r in range(len(df)):
            for ci, col in enumerate(self._columns):
                val = df.iloc[r].get(col, "")
                if is_image_marker(val):
                    # Show a thumbnail
                    meta = parse_image_marker(val)
                    pth = meta.get("path", "")
                    if pth and os.path.exists(pth):
                        label = QLabel()
                        pm = QPixmap(pth)
                        if not pm.isNull():
                            pix = pm.scaled(300, 180, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
                            label.setPixmap(pix)
                            label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                            label.setStyleSheet("border:1px solid #ccc;background:#fff;")
                            self.table.setIndexWidget(self._model.index(r, ci), label)
                            self.table.setRowHeight(r, max(self.table.rowHeight(r), 200))
                        else:
                            self._model.setItem(r, ci, QStandardItem(f"[Image not readable] {os.path.basename(pth)}"))
                    else:
                        self._model.setItem(r, ci, QStandardItem("[Missing Image]"))
                elif is_table_marker(val):
                    rows, cols2, data, name = load_table_payload(val)
                    lbl = f"{name} — " if name else ""
                    self._model.setItem(r, ci, QStandardItem(f"{lbl}Table {rows}x{cols2}"))
                else:
                    it = QStandardItem(str(val))
                    self._model.setItem(r, ci, it)

        # edits propagate back into self.df
        try:
            self._model.itemChanged.disconnect()
        except Exception:
            pass
        self._model.itemChanged.connect(self._on_item_changed)

        for c in range(self._model.columnCount()):
            try:
                self.table.resizeColumnToContents(c)
            except Exception:
                pass

    def _on_item_changed(self, item: QStandardItem):
        if self.df is None:
            return
        try:
            r = item.row()
            c = item.column()
            col_name = self._columns[c]
            self.df.at[r, col_name] = item.text().strip()
            # Optionally renumber on edits to Object Type / Object Text:
            if col_name in ("Object Type", "Object Text"):
                self.df = renumber_headings_and_requirements(self.df)
                self.df = renumber_figures_and_tables(self.df)
        except Exception:
            pass

    # Minimal context menu with filter/sort placeholder (optional)
    def _open_context_menu(self, pos):
        index = self.table.indexAt(pos)
        if not index.isValid():
            return
        # (kept simple—your main header filter UI can remain in MainWindow if needed)
        menu = QMenu(self)
        menu.addAction("Resize Columns to Contents", lambda: [self.table.resizeColumnToContents(i) for i in range(self._model.columnCount())])
        menu.exec(self.table.viewport().mapToGlobal(pos))

    @staticmethod
    def _text_to_html_blocks(raw: str) -> str:
        s = (raw or "").strip()
        if not s:
            return ""
        lines = [ln.rstrip() for ln in s.splitlines() if ln.strip()]
        if not lines:
            return ""
        ul_m = ("- ", "• ", "* ")
        if all(any(ln.lstrip().startswith(m) for m in ul_m) for ln in lines):
            items = []
            for ln in lines:
                for m in ul_m:
                    if ln.lstrip().startswith(m):
                        items.append(f"<li>{ln.lstrip()[len(m):].strip()}</li>")
                        break
            return "<ul>" + "".join(items) + "</ul>"
        if all(re.match(r"^\s*\d+\.\s+", ln) for ln in lines):
            import re as _re
            items = ["<li>" + _re.sub(r'^\s*\d+\.\s+','', ln) + "</li>" for ln in lines]
            return "<ol>" + "".join(items) + "</ol>"
        return "".join(f"<p>{ln}</p>" for ln in lines)


class MainWindow(QMainWindow):

    def _projects_root(self) -> Path:
        """<repo>/projects regardless of CWD (matches Main_page)."""
        here = Path(__file__).resolve()
        repo_root = here.parents[2]            # .../Requirement-Management-Tool
        projects = (repo_root / "projects").resolve()
        projects.mkdir(parents=True, exist_ok=True)
        return projects

    def _reset_ui_state(self) -> None:
        """Clear all in-memory/UI artifacts so a new project opens cleanly."""
        try:
            # tabs & per-tab table cache
            if hasattr(self, "tab_widget"):
                self.tab_widget.clear()
            if hasattr(self, "table_tabs"):      # dict[str, QWidget] or similar
                self.table_tabs.clear()
            if hasattr(self, "_tab_tables"):     # map of QTableWidget per tab
                self._tab_tables.clear()
            # side panes
            if hasattr(self, "search_results"):
                self.search_results.clear()
            if hasattr(self, "nav_tree"):
                self.nav_tree.clear()
            # data / profiles
            if hasattr(self, "data_manager"):
                try:
                    import pandas as pd  # noqa
                    self.data_manager.dataframe = self.data_manager.finalize_dataframe(pd.DataFrame())
                except Exception:
                    pass
            if hasattr(self, "header_profiles"):
                self.header_profiles = {}
            # refresh central view if applicable
            if hasattr(self, "populate_table"):
                self.populate_table()
        except Exception:
            pass

    def set_project_name(self, name: str):
        """Set project name, ensure folder, and restore previous contents."""
        self._reset_ui_state()
        self.project_name = name
        self.project_path = (self._projects_root() / name).resolve()
        self.project_path.mkdir(parents=True, exist_ok=True)
        self.project_meta = self.project_path / "project.json"

        if hasattr(self, "project_label"):
            try:
                self.project_label.setText(f"Project: {self.project_name}")
            except Exception:
                pass
        try:
            self.setWindowTitle(f"Mach Requirement Management Tool — {self.project_name}")
        except Exception:
            pass

        # 1) Prefer a full state restore if we have it
        restored = self._load_project_state()
        if restored:
            return

        # 2) Fallback to project.json-driven reload (local copies inside project folder)
        try:
            if self.project_meta.exists():
                meta = json.loads(self.project_meta.read_text(encoding="utf-8"))
                excel_files = [str(self.project_path / Path(n).name)
                            for n in (meta.get("excel_files") or [])]
                word_files = [str(self.project_path / Path(n).name)
                            for n in (meta.get("word_files") or [])]
                word_pattern = meta.get("word_pattern") or None
                header_profiles = meta.get("header_profiles")

                loading = LoadingDialog(f"Restoring project '{self.project_name}'...", self)
                loading.setWindowModality(Qt.WindowModality.ApplicationModal)
                loading.show()
                QApplication.processEvents()  # force render now

                def _delayed_restore():
                    try:
                        excel_existing = [p for p in excel_files if Path(p).exists()]
                        if excel_existing:
                            self._import_excel_files(excel_existing)
                            self.log_console(f"Restored {len(excel_existing)} Excel files.")

                        word_existing = [p for p in word_files if Path(p).exists()]
                        if word_existing:
                            pattern = word_pattern or self._prompt_requirement_pattern()
                            if pattern:
                                self._import_word_files(word_existing, pattern)
                                self.log_console(f"Restored {len(word_existing)} Word files.")

                        if header_profiles:
                            self.header_profiles = header_profiles

                        self.log_console("Project restore complete.")
                    except Exception as e:
                        self.log_console(f"Delayed restore failed: {e}")
                    finally:
                        loading.close()

                # Schedule restore slightly later so popup remains visible
                QTimer.singleShot(200, _delayed_restore)
                return

            # 3) Nothing to restore → start clean (prevents cross-project bleed)
            self.header_profiles.clear()
            if hasattr(self, "data_manager"):
                self.data_manager.dataframe = self.data_manager.create_empty_dataframe()
                self._undo_stack = [self.data_manager.dataframe.copy()]
            self.populate_table()
            self._save_project_state()
            self.log_console(f"Project '{self.project_name}' ready (new) at {self.project_path}")
        except Exception as e:
            self.log_console(f"Restore failed: {e}")

        

    # ----- Project cache utils -----
    def _read_store(self) -> dict:
        if PROJECT_STORE_PATH.exists():
            try:
                return json.loads(PROJECT_STORE_PATH.read_text(encoding="utf-8"))
            except Exception:
                return {}
        return {}

    def _write_store(self, store: dict) -> None:
        try:
            PROJECT_STORE_PATH.write_text(json.dumps(store, indent=2), encoding="utf-8")
        except Exception:
            pass

    def _touch_recent_project(self, name: str) -> None:
        if not name:
            return
        store = self._read_store()
        projects = store.setdefault("projects", {})
        entry = projects.setdefault(name, {})
        entry["last_opened"] = int(time.time())
        # persist header profiles for this project
        entry["header_profiles"] = self.header_profiles
        self._write_store(store)
        self._refresh_recent_projects_ui()

    def _load_project_profiles(self, name: str) -> Dict[str, Dict[str, object]]:
        store = self._read_store()
        proj = store.get("projects", {}).get(name, {})
        return proj.get("header_profiles", {}) or {}

    def _recent_projects(self) -> list[str]:
        store = self._read_store()
        items = list((store.get("projects") or {}).items())
        # sort by last_opened desc
        items.sort(key=lambda kv: int(kv[1].get("last_opened", 0)), reverse=True)
        return [k for k, _ in items]

    def __init__(self, data_manager: Optional[RequirementDataManager] = None):
        super().__init__()
        self.data_manager = data_manager or RequirementDataManager()
        self.setWindowTitle("Mach Requirement Management Tool")
        self.resize(1300, 800)
        self.setAcceptDrops(True)
        self.project_name: str | None = None

        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        self.setAcceptDrops(True)  
        # ---------- Project header bar (below window title) ----------
        header_bar = QHBoxLayout()
        self.project_label = QLabel("No project open")
        self.project_label.setStyleSheet("font-weight: 600;")
        self.create_project_btn = QPushButton("＋ Create Project")
        self.create_project_btn.setObjectName("createProject")
        self.create_project_btn.setToolTip("Create a new project and start adding requirements")
        self.create_project_btn.clicked.connect(self.create_project)
        header_bar.addWidget(self.project_label)
        header_bar.addStretch()
        header_bar.addWidget(self.create_project_btn)
        main_layout.addLayout(header_bar)
        # Subtle style to make the CTA stand out
        self.setStyleSheet("#createProject { font-size: 15px; padding: 8px 14px; }")

        button_row = QHBoxLayout()
        # 🏠 Home button
        self.home_btn = QPushButton("🏠 Home")
        self.home_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.home_btn.clicked.connect(self.return_to_main_page)
        button_row.addWidget(self.home_btn)
        self.load_btn = QPushButton('Load Excel')
        self.load_btn.clicked.connect(self.load_excels)
        self.load_word_btn = QPushButton('Load Word')
        self.load_word_btn.clicked.connect(self.load_word_documents)
        self.run_btn = QPushButton('Run (Convert to Word)')
        self.run_btn.clicked.connect(self.run_convert_preview)
        self.back_btn = QPushButton('Back to Table View')
        self.back_btn.clicked.connect(self.show_table_view)
        self.save_btn = QPushButton('Save Word')
        self.save_btn.clicked.connect(self.save_word)
        self.trace_btn = QPushButton('Traceability Matrix')
        self.trace_btn.clicked.connect(self.show_trace_view)
        self.save_excel_btn = QPushButton('Save Excel')
        self.save_excel_btn.clicked.connect(self.save_excel_with_images)

        # Quick navigation / editing helpers
        QShortcut(QKeySequence("Ctrl+E"), self, activated=self.focus_excel_tab if hasattr(self, "focus_excel_tab") else lambda: None)
        QShortcut(QKeySequence("Alt+Down"), self, activated=self._open_header_menu_shortcut if hasattr(self, "_open_header_menu_shortcut") else lambda: None)
        for n in (1,2,3,4,5,6):
            QShortcut(QKeySequence(f"Alt+{n}"), self,
                      activated=lambda lvl=n: getattr(self, "_set_heading_level_shortcut", lambda *_: None)(lvl))
            
        # ---------------- Search Bar ----------------
                
        search_row = QHBoxLayout()
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Search Requirement, Table, or Text...")
        self.btn_search = QPushButton("Find Next")
        self.btn_prev = QPushButton("Find Previous")
        self.btn_clear_results = QPushButton("Clear Results")
        search_row.addWidget(QLabel("🔍 Search:"))
        search_row.addWidget(self.search_input, 4)
        search_row.addWidget(self.btn_prev)
        search_row.addWidget(self.btn_search)
        search_row.addWidget(self.btn_clear_results)
        main_layout.addLayout(search_row)

            # --------------------------------------------
        for button in (
            self.load_btn,
            self.load_word_btn,
            self.run_btn,
            self.back_btn,
            self.save_btn,
            self.trace_btn,
            self.save_excel_btn,
        ):
            button_row.addWidget(button)
        main_layout.addLayout(button_row)

        attachment_row = QHBoxLayout()
        self.add_image_btn = QPushButton("Add Image")
        self.add_image_btn.clicked.connect(self.add_image_attachment)
        self.add_table_btn = QPushButton("Add Table")
        self.add_table_btn.clicked.connect(self.add_table_attachment)
        self.edit_header_btn = QPushButton("Edit Header Details")
        self.edit_header_btn.clicked.connect(self.edit_header_details)
        self.remove_tab_btn = QPushButton("Remove Tab")
        self.remove_tab_btn.clicked.connect(self.remove_current_tab)
        for button in (
            self.add_image_btn,
            self.add_table_btn,
            self.edit_header_btn,
            self.remove_tab_btn,
        ):
            attachment_row.addWidget(button)
        attachment_row.addStretch()
        main_layout.addLayout(attachment_row)


        center_row = QHBoxLayout()
        main_layout.addLayout(center_row)

        # ---------------- Left Panel: Navigation + Search Results ----------------
        left_panel = QVBoxLayout()
        left_widget = QWidget()
        left_widget.setLayout(left_panel)
        center_row.addWidget(left_widget, 2)

        # Toggle buttons for Navigation and Search Results
        nav_toggle_row = QHBoxLayout()
        self.btn_nav_view = QPushButton("📜 Navigation")
        self.btn_search_view = QPushButton("🔍 Search")
        self.btn_nav_view.setCheckable(True)
        self.btn_search_view.setCheckable(True)
        self.btn_nav_view.setChecked(True)
        nav_toggle_row.addWidget(self.btn_nav_view)
        nav_toggle_row.addWidget(self.btn_search_view)
        left_panel.addLayout(nav_toggle_row)

        # Stacked widget to switch between navigation tree and search results list
        self.left_stack = QStackedWidget()

        # --- Navigation Tree ---
        self.nav_tree = QTreeWidget()
        self.nav_tree.setHeaderLabel("Navigation")
        self.nav_tree.itemClicked.connect(self.on_nav_item_clicked)
        self.left_stack.addWidget(self.nav_tree)

        # --- Search Results List ---
        self.search_results = QListWidget()
        self.search_results.setSelectionMode(QListWidget.SelectionMode.SingleSelection)
        self.left_stack.addWidget(self.search_results)

        # Add stacked widget to panel
        left_panel.addWidget(self.left_stack)
        left_panel.setStretchFactor(self.left_stack, 1)

       

        # Connect buttons to toggle view
        self.btn_nav_view.clicked.connect(lambda: self._toggle_left_panel(0))
        self.btn_search_view.clicked.connect(lambda: self._toggle_left_panel(1))
        self.search_results.itemClicked.connect(self.navigate_to_search_result)

         # ---------------- Connections ----------------
        self.btn_search.clicked.connect(self.find_next_match)
        self.btn_prev.clicked.connect(self.find_previous_match)
        self.btn_clear_results.clicked.connect(self.clear_search_results)
# (dedup)         self.search_results.itemClicked.connect(self.navigate_to_search_result)
        self.search_input.returnPressed.connect(self.run_search)

        self.view_stack = QStackedWidget()
        center_row.addWidget(self.view_stack, 8)

        # ---------- Front (Welcome) Page with big Create button ----------
        self.front_page = QWidget()
        fp_layout = QVBoxLayout(self.front_page)
        fp_layout.setContentsMargins(32, 32, 32, 32)
        title = QLabel("Welcome — Create a Project to get started")
        title.setStyleSheet("font-size: 18px; font-weight: 700;")
        title.setAlignment(Qt.AlignmentFlag.AlignHCenter)
        big_btn = QPushButton("＋ Create Project")
        big_btn.setMinimumHeight(56)
        big_btn.setStyleSheet("font-size: 16px;")
        big_btn.setToolTip("Create a new project and go to the Requirements tab")
        big_btn.clicked.connect(self.create_project)
        hint = QLabel("You can also load existing Excel/Word sources after creating a project.")
        hint.setAlignment(Qt.AlignmentFlag.AlignHCenter)
        fp_layout.addStretch(1)
        fp_layout.addWidget(title)
        fp_layout.addSpacing(16)
        fp_layout.addWidget(big_btn, 0, Qt.AlignmentFlag.AlignHCenter)
        fp_layout.addSpacing(12)
        fp_layout.addWidget(hint)
        fp_layout.addSpacing(16)

        # Recent projects list
        self.recent_label = QLabel("Recent Projects")
        self.recent_label.setStyleSheet("font-weight: 600;")
        self.recent_list = QListWidget()
        self.recent_list.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.recent_list.itemDoubleClicked.connect(self._open_recent_from_item)
        fp_layout.addWidget(self.recent_label)
        fp_layout.addWidget(self.recent_list, 1)
        fp_layout.addStretch(2)
        self.view_stack.addWidget(self.front_page)  # index 0

        self.table_tabs = QTabWidget()
        self.table_tabs.currentChanged.connect(self.on_table_tab_changed)
        self.view_stack.addWidget(self.table_tabs)

        self.word_preview = QTextBrowser()
        self.view_stack.addWidget(self.word_preview)

        self.trace_view = TraceMatrixView(self)
        self.trace_view.navigate_to_requirement = self.navigate_to_requirement
        self.view_stack.addWidget(self.trace_view)

        # Show the front page on startup
        self.view_stack.setCurrentWidget(self.front_page)
        self.console = QTextBrowser()
        self.console.setFixedHeight(120)
        main_layout.addWidget(self.console)

        # ---------- Excel-like preview helpers ----------
        # Per-tab filters: { "TabName": {col_index: set(values)} }
        self._table_filters: Dict[str, Dict[int, set[str]]] = {}
        # Per-tab sort: { "TabName": (col_index, ascending: bool) }
        self._table_sort: Dict[str, tuple[int, bool]] = {}
        # Object Type options for the in-grid dropdown
        self._object_types: list[str] = [
            "Heading 1", "Heading 2", "Heading 3",
            "Requirement", "Image", "Table", "Text"
        ]

        QShortcut(QKeySequence("Ctrl+Z"), self, activated=self.undo_last)
        QShortcut(QKeySequence("Ctrl+E"), self, activated=self._focus_excel_tab)
        QShortcut(QKeySequence("Alt+Down"), self, activated=self._open_header_menu_shortcut)
        for n in (1, 2, 3,4,5,6):
            QShortcut(QKeySequence(f"Alt+{n}"), self, activated=partial(self._set_heading_level_shortcut, n))


        self._undo_stack: list[pd.DataFrame] = []
        self._loading = False
        self._tab_tables: Dict[str, QTableWidget] = {}
        self._tab_indices: Dict[str, list[int]] = {}
        self._tab_source_types: Dict[str, str] = {}
        self._last_pattern_config: dict[str, str] = {"mode": "prefixes", "value": ""}
        self.default_header_settings = {
            "document_title": "Software Requirements Specification for Gateway Module of EDAU in UH-60X Engine Instrument System",
            "document_number": "MGT-H398-GWY-S001",
            "revision": "2.4",
            "author_name": "",
            "author_title": "(Software Engineer)",
            "reviewer_name": "",
            "reviewer_title": "(Software Engineer)",
            "qa_name": "Anitha K",
            "qa_title": "(Quality Assurance Engineer)",
            "config_manager_name": "Krishnamoorthy Duraiswamy",
            "config_manager_title": "(Engineering Manager)",
            "logo_left_path": DEFAULT_HOWELL_LOGO if Path(DEFAULT_HOWELL_LOGO).exists() else "",
            "logo_right_path": DEFAULT_MACH_LOGO if Path(DEFAULT_MACH_LOGO).exists() else "",
            "preview_image_width_percent": 80,
            "export_image_width_inches": 5.5,
            "address_howell": "Howell Instruments, Inc.<br/>8945 South Freeway<br/>Fort Worth, Texas, 76140<br/>U.S.A.",
            "address_mach": "Mach Global Technologies<br/>No 42/4A, Shantipura Road, Electronic City,<br/>Phase 2, Bengaluru, Karnataka 560100, India",
            "proprietary_notice": (
                "This document and the information contained herein are the property of Howell Instruments, Inc. "
                "Any reproduction, disclosure or use thereof is prohibited except as authorized in writing by Howell Instruments, Inc. "
                "Recipient accepts the responsibility for maintaining the confidentiality of the contents of this document."
            ),
            "copyright_notice": "© 2025 Howell Instruments. All rights reserved.",
            "watermark_text": "",
        }
        self.header_profiles: Dict[str, Dict[str, object]] = {}
        self.console.append("Application Ready.")
        try:
            self.view_stack.setCurrentWidget(self.table_tabs)
        except Exception:
            pass
        for _name in ('front_page','create_project_btn','recent_list'):
            try:
                _w = getattr(self, _name)
                _w.hide()
                if _name == 'front_page':
                    try:
                        self.view_stack.removeWidget(_w)
                    except Exception:
                        pass
            except Exception:
                pass
        self._wire_tooltips()

    # ------------------------------------------------------------------
    def _show_table_context_menu(self, table: QTableWidget, pos: QPoint) -> None:
        row = table.currentRow()
        col = table.currentColumn()
        menu = QMenu(table)

        act_add_above = menu.addAction("Add Row Above")
        act_add_below = menu.addAction("Add Row Below")
        act_dup       = menu.addAction("Duplicate Row")
        act_del       = menu.addAction("Delete Row")
        menu.addSeparator()
        act_img       = menu.addAction("🖼 Insert Image")
        act_tbl       = menu.addAction("📋 Insert Table")
        menu.addSeparator()
        act_hide_col  = menu.addAction("Hide Column")
        act_show_cols = menu.addAction("Show All Columns")
        act_hide_row  = menu.addAction("Hide Row")
        act_show_rows = menu.addAction("Show All Rows")
        menu.addSeparator()
        act_undo      = menu.addAction("Undo (Ctrl+Z)")
        menu.addSeparator()
        act_preview   = menu.addAction("Open HTML Preview")

        def _row_guard() -> bool:
            if row < 0:
                QMessageBox.information(self, "No selection", "Select a row first.")
                return False
            return True

        def add_row(offset: int) -> None:
            if not _row_guard(): return
            try:
                insert_at = max(0, row + offset)
                # Minimal blank record; DataManager will normalize
                self.data_manager.insert_attachment(
                    object_type="Text",
                    attachment_type="",
                    attachment_data="",
                    object_text="",
                    requirement_id="",
                    insert_at=insert_at,
                    source_file="Manual", sheet_name="Manual", source_type="manual",
                )
                self.populate_table()
            except Exception as exc:
                QMessageBox.critical(self, "Insert Row Error", str(exc))

        def duplicate_row() -> None:
            if not _row_guard(): return
            try:
                df = self.data_manager.get_dataframe()
                if row >= len(df): return
                rec = df.iloc[row].to_dict()
                self.data_manager.insert_attachment(
                    object_type=str(rec.get("Object Type","") or "Text"),
                    attachment_type=str(rec.get("Attachment Type","") or ""),
                    attachment_data=str(rec.get("Attachment Data","") or ""),
                    object_text=str(rec.get("Object Text","") or ""),
                    requirement_id=str(rec.get("Requirement ID","") or ""),
                    insert_at=row+1,
                    source_file=str(rec.get("SourceFile","Manual") or "Manual"),
                    sheet_name=str(rec.get("SheetName","Manual") or "Manual"),
                    source_type=str(rec.get("SourceType","manual") or "manual"),
                )
                self.populate_table()
            except Exception as exc:
                QMessageBox.critical(self, "Duplicate Row Error", str(exc))

        def delete_row() -> None:
            if not _row_guard(): return
            try:
                df = self.data_manager.get_dataframe().copy()
                if 0 <= row < len(df):
                    df = df.drop(df.index[row]).reset_index(drop=True)
                    self.data_manager.set_dataframe(df)
                    self.populate_table()
            except Exception as exc:
                QMessageBox.critical(self, "Delete Row Error", str(exc))

        def insert_image() -> None:
            # Your app may already provide a dialog; call it if available
            if hasattr(self, "insert_image_dialog"):
                self.insert_image_dialog(insert_at=row if row >= 0 else None)
            else:
                self.log_console("Insert Image dialog not wired.")

        def insert_table() -> None:
            if hasattr(self, "insert_table_dialog"):
                self.insert_table_dialog(insert_at=row if row >= 0 else None)
            else:
                self.log_console("Insert Table dialog not wired.")

        def hide_column() -> None:
            if col >= 0:
                table.setColumnHidden(col, True)

        def show_all_columns() -> None:
            for c in range(table.columnCount()):
                table.setColumnHidden(c, False)

        def hide_row() -> None:
            if row >= 0:
                table.setRowHidden(row, True)

        def show_all_rows() -> None:
            for r in range(table.rowCount()):
                table.setRowHidden(r, False)

        def do_undo() -> None:
            # Your existing undo method name may differ
            if hasattr(self, "undo_last"):
                self.undo_last()
            elif hasattr(self, "undo"):
                self.undo()
            else:
                self.log_console("Undo not wired.")

        def open_preview() -> None:
            # Switch to Preview tab if app exposes a method for this
            if hasattr(self, "show_preview_tab"):
                self.show_preview_tab()
            elif hasattr(self, "on_preview_clicked"):
                self.on_preview_clicked()
            else:
                self.log_console("Preview not wired; please map 'Open HTML Preview' to your preview tab.")

            act_add_above.triggered.connect(lambda: add_row(0))
            act_add_below.triggered.connect(lambda: add_row(1))
            act_dup.triggered.connect(duplicate_row)
            act_del.triggered.connect(delete_row)
            act_img.triggered.connect(insert_image)
            act_tbl.triggered.connect(insert_table)
            act_hide_col.triggered.connect(hide_column)
            act_show_cols.triggered.connect(show_all_columns)
            act_hide_row.triggered.connect(hide_row)
            act_show_rows.triggered.connect(show_all_rows)
            act_undo.triggered.connect(do_undo)
            act_preview.triggered.connect(open_preview)

            menu.exec(table.viewport().mapToGlobal(pos))

    def log_console(self, message: str) -> None:
        LOGGER.info(message)
        self.console.append(message)

    def return_to_main_page(self):
        if hasattr(self.parent(), "return_to_main_page"):
            self.parent().return_to_main_page()

    # ---------- New: Project helpers ----------
    def _refresh_recent_projects_ui(self) -> None:
        return

    def _open_recent_from_item(self, item: QListWidgetItem) -> None:
        name = str(item.data(Qt.ItemDataRole.UserRole) or "").strip()
        if not name or name == "(No recent projects)":
            return
        self.open_project(name)

    def _update_project_ui(self) -> None:
        pass

    def open_project(self, name: str) -> None:
        """Open project context without manual data creation or recent-store updates."""
        self.project_name = name
        try:
            self.view_stack.setCurrentWidget(self.table_tabs)
        except Exception:
            pass
        self.log_console(f'Opened project context: {name}')

    def create_project(self) -> None:
        """Project creation is handled in Main Page UI. No auto-creation of Manual tab."""
        try:
            self.view_stack.setCurrentWidget(self.table_tabs)
        except Exception:
            pass
        self.log_console('Project creation is handled in Main Page UI.')

    # ---------- New: Tooltips for primary controls ----------
    def _wire_tooltips(self) -> None:
        tips = {
            self.load_btn: "Load one or more Excel files (requirements workbook)",
            self.load_word_btn: "Load one or more Word documents (.docx) and extract requirements",
            self.run_btn: "Generate the live Word-style preview (with front page/TOC/figures/tables)",
            self.back_btn: "Return to the editable Requirements table view",
            self.save_btn: "Export current project to a Word (.docx) file",
            self.trace_btn: "Open the Traceability Matrix (forward/backward) for selected tabs",
            self.save_excel_btn: "Export grouped requirements to Excel (with image thumbnails)",
            self.add_image_btn: "Insert an image as an attachment below the selected row",
            self.add_table_btn: "Insert a table attachment from CSV/Excel below the selected row",
            self.edit_header_btn: "Edit header/footer, front page details, logos and watermark",
            self.remove_tab_btn: "Remove the current tab’s data from the project",
            self.btn_nav_view: "Show the navigation tree (Headings 1–3)",
            self.btn_search_view: "Show search results for the current tab",
            self.btn_search: "Go to the next search match",
            self.btn_prev: "Go to the previous search match",
            self.btn_clear_results: "Clear all search matches and results",
            self.search_input: "Type text and press Enter to search within the current tab",
            self.home_btn: "Return to the Home page",
        }
        for w, t in tips.items():
            try:
                w.setToolTip(t)  # only where available
            except Exception:
                pass

    # ------------------------------------------------------------------
    def _header_key(self, source: Optional[str]) -> str:
        return source or "__default__"

    # ------------------------------------------------------------------
    def _get_header_settings(self, source: Optional[str] = None) -> Dict[str, object]:
        key = self._header_key(source or self._current_source_name())
        if key not in self.header_profiles:
            self.header_profiles[key] = copy.deepcopy(self.default_header_settings)
        return self.header_profiles[key]

    # ------------------------------------------------------------------
    def _ensure_header_profile(self, source: Optional[str]) -> None:
        self._get_header_settings(source)

    # ------------------------------------------------------------------
    def _current_table(self) -> Optional[QTableWidget]:
        widget = self.table_tabs.currentWidget()
        if isinstance(widget, QTableWidget):
            return widget
        return None

    # ------------------------------------------------------------------
    def _current_source_name(self) -> str:
        table = self._current_table()
        if table is None:
            return ""
        source = table.property("source")
        return str(source) if source is not None else ""

    # ------------------------------------------------------------------
    def _get_dataframe_for_source(
        self, source: Optional[str] = None, raw: bool = False
    ) -> pd.DataFrame:
        df = self.data_manager.dataframe
        if df.empty:
            return pd.DataFrame()
        key = source or self._current_source_name()
        if key in self._tab_indices:
            indices = self._tab_indices.get(key, [])
            if indices:
                subset = df.loc[indices]
                return subset if raw else subset.reset_index(drop=True).copy()
            return pd.DataFrame()
        return df if raw else df.copy()

    # ------------------------------------------------------------------
    def _default_sheet_name(self, source: str) -> str:
        df = self.data_manager.dataframe
        if df.empty or "SheetName" not in df.columns:
            return "Manual"
        if source in self._tab_indices:
            indices = self._tab_indices.get(source, [])
            if indices:
                subset = df.loc[indices]
                first = str(subset.iloc[0].get("SheetName", "")).strip()
                if first:
                    return first
        if "SourceFile" in df.columns:
            matches = df[df["SourceFile"] == source]
            if not matches.empty:
                first = str(matches.iloc[0].get("SheetName", "")).strip()
                if first:
                    return first
        return "Manual"

    # ------------------------------------------------------------------
    def _create_table_widget(self) -> QTableWidget:
        table = QTableWidget()
        table.setEditTriggers(
            QTableWidget.EditTrigger.AnyKeyPressed | QTableWidget.EditTrigger.DoubleClicked | QTableWidget.EditTrigger.EditKeyPressed
        )
        table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        table.customContextMenuRequested.connect(
            lambda position, table=table: self.table_context_menu(table, position)
        )
        table.itemChanged.connect(lambda item, t=table: self.on_table_cell_changed(item))
        table.itemDoubleClicked.connect(self.on_table_item_double_clicked)
        table.setWordWrap(True)
        header = table.horizontalHeader()
        header.setStretchLastSection(False)
        header.setSectionResizeMode(QHeaderView.ResizeMode.Interactive)
        v_header = table.verticalHeader()
        v_header.setSectionResizeMode(QHeaderView.ResizeMode.Interactive)
        v_header.setDefaultSectionSize(48)
        return table

    # ------------------------------------------------------------------
    def _column_name_for_item(self, item: QTableWidgetItem | None) -> Optional[str]:
        if item is None:
            return None
        table = item.tableWidget()
        if table is None:
            return None
        header_item = table.horizontalHeaderItem(item.column())
        if header_item is None:
            return None
        return header_item.text()

    # ------------------------------------------------------------------
    def _extract_primary_identifier(self, value: str) -> str:
        candidates = re.findall(r"[A-Za-z0-9][A-Za-z0-9_.-]*", value or "")
        for candidate in candidates:
            if any(char.isdigit() for char in candidate):
                return candidate
        return value.strip()

    # ------------------------------------------------------------------
    def _navigate_to_trace_from_cell(self, raw_value: str) -> None:
        target = self._extract_primary_identifier(raw_value)
        if not target:
            self.log_console("No requirement ID detected in Up Trace cell.")
            return
        if not self._switch_to_trace_view(target):
            return
        
    # ------------------------------------------------------------------    
    def _scroll_preview_to_row(self, global_index: int, highlight_candidates: list[str]) -> None:
        """Scroll Word preview to row anchor and flash-highlight nearby text."""
        if self.view_stack.currentWidget() is not self.word_preview:
            return
        anchor = f"row-{int(global_index)}"
        self.word_preview.scrollToAnchor(anchor)

        # Try to highlight something readable at/near the anchor
        # (RID first, then a snippet), using your existing helper.
        matched = self._highlight_preview_text([c for c in highlight_candidates if c])
        if matched:
            self.log_console(f"Preview focused: {matched}")

    # ------------------------------------------------------------------
    def on_table_item_double_clicked(self, item: QTableWidgetItem) -> None:
        column_name = self._column_name_for_item(item)
        if not column_name:
            return
        normalized = column_name.strip().lower()
        if normalized == "up trace":
            cell_value = item.text().strip() if item else ""
            if cell_value:
                self._navigate_to_trace_from_cell(cell_value)
        elif normalized in {"requirement id","req id","reqid"}:
            cell_value = item.text().strip() if item else ""
            if cell_value:
                self._navigate_to_trace_from_cell(cell_value)
        elif normalized == "object text":
            table = item.tableWidget()
            if table is not None:
                widget = table.cellWidget(item.row(), item.column())
                if widget is not None:
                    widget.setFocus()
        else:
            table = item.tableWidget()
            if table is not None:
                table.editItem(item)

    # ------------------------------------------------------------------
    def _calculate_insert_position(self, table: QTableWidget, insert_after: bool) -> int:
        indices = self._tab_indices.get(str(table.property("source") or ""), [])
        current_row = table.currentRow()
        if current_row < 0 or current_row >= len(indices):
            return len(self.data_manager.dataframe)
        base_index = int(indices[current_row])
        return base_index + 1 if insert_after else base_index

    # ------------------------------------------------------------------
    def _insert_blank_row(self, source: str, position: int, source_type: str) -> None:
        df = self.data_manager.dataframe
        if df.empty:
            columns = list(REQUIRED_COLUMNS) + list(OPTIONAL_METADATA_COLUMNS) + [
                self.data_manager.section_column_name
            ]
            df = pd.DataFrame(columns=columns)

        record = {col: "" for col in df.columns}
        record[self.data_manager.section_column_name] = ""
        record["SourceFile"] = source
        if "SheetName" in record:
            record["SheetName"] = self._default_sheet_name(source)
        if "SourceType" in record:
            record["SourceType"] = source_type

        upper = df.iloc[:position]
        lower = df.iloc[position:]
        new_df = pd.concat([upper, pd.DataFrame([record]), lower], ignore_index=True)
        finalized = self.data_manager.finalize_dataframe(new_df)
        self.data_manager.dataframe = finalized
        self._undo_stack.append(finalized.copy())
        self.populate_table()

    # ------------------------------------------------------------------
    def _delete_rows(self, indices: list[int]) -> None:
        if not indices:
            return
        df = self.data_manager.dataframe.drop(index=indices).reset_index(drop=True)
        finalized = self.data_manager.finalize_dataframe(df)
        self.data_manager.dataframe = finalized
        self._undo_stack.append(finalized.copy())
        self.populate_table()

    # ------------------------------------------------------------------
    def remove_current_tab(self) -> None:
        table = self._current_table()
        if table is None:
            QMessageBox.information(self, "Remove Tab", "No tab is currently selected.")
            return
        source = str(table.property("source") or "")
        if not source or source == "No Data":
            QMessageBox.information(self, "Remove Tab", "Cannot remove this tab.")
            return
        indices = list(self._tab_indices.get(source, []))
        if not indices:
            QMessageBox.information(
                self, "Remove Tab", "No rows are associated with this tab."
            )
            return
        reply = QMessageBox.question(
            self,
            "Remove Tab",
            f"Remove all data for tab '{source}'?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No,
        )
        if reply != QMessageBox.StandardButton.Yes:
            return
        self.header_profiles.pop(self._header_key(source), None)
        self._tab_source_types.pop(source, None)
        self._delete_rows(indices)
        self.log_console(f"Removed tab: {source}")
        self._save_project_state()

    # ------------------------------------------------------------------
    def _select_global_row(self, source: str, global_index: int) -> None:
        table = self._tab_tables.get(source)
        if table is None:
            return
        indices = self._tab_indices.get(source, [])
        try:
            row = indices.index(global_index)
        except ValueError:
            return
        table.blockSignals(True)
        try:
            table.setCurrentCell(row, 0)
            table.selectRow(row)
            item = table.item(row, 0)
            if item is not None:
                table.scrollToItem(item)
        finally:
            table.blockSignals(False)

    # ------------------------------------------------------------------
    def _select_source_tab(self, source: str) -> None:
        if not source:
            source = "Manual"
        for index in range(self.table_tabs.count()):
            widget = self.table_tabs.widget(index)
            if isinstance(widget, QTableWidget):
                if str(widget.property("source") or "Manual") == source:
                    self.table_tabs.setCurrentIndex(index)
                    break

    # ------------------------------------------------------------------
    def _show_reorder_dialog(self, files: Sequence[str]) -> Optional[list[str]]:
        if not files:
            return None
        if len(files) == 1:
            return list(files)
        dlg = ReorderFilesDialog(files, self, "Reorder Excel Files")
        if dlg.exec() == QDialog.DialogCode.Accepted:
            ordered = dlg.ordered_paths()
            if not ordered:
                return None
            return ordered
        return None

    def _import_excel_files(self, files: Sequence[str]) -> None:
        normalized = [str(Path(path)) for path in files if path]
        if not normalized:
            return
        try:
            new_df = self.data_manager.load_workbooks(normalized)
        except RequirementDataError as exc:
            LOGGER.exception("Failed to load workbooks")
            QMessageBox.critical(self, "Load Error", str(exc))
            return
        df = self.data_manager.merge_new_dataframe(new_df)
        self._ensure_header_profile("Excel")
        self._undo_stack = [df.copy()]
        self.populate_table()
        self.log_console("Excel files loaded and numbering applied.")

    # ------------------------------------------------------------------
    def _prompt_requirement_pattern(self) -> Optional[dict[str, str]]:
        dialog = RequirementPatternDialog(self, self._last_pattern_config)
        if dialog.exec() != QDialog.DialogCode.Accepted:
            return None
        config = dialog.result_config()
        self._last_pattern_config = config
        return config

    # ------------------------------------------------------------------
    def _import_word_files(self, files: Sequence[str], pattern: Optional[dict[str, str]] | None = None) -> None:
        # (dedup) from PyQt6.QtWidgets import QProgressDialog
        from PyQt6.QtCore import Qt

        normalized = [str(Path(path)) for path in files if path]
        if not normalized:
            return

        cfg = pattern if (pattern and pattern.get("value")) else self._last_pattern_config
        self.data_manager.configure_requirement_pattern(cfg)

        progress = QProgressDialog("Loading requirements...", None, 0, 100, self)
        progress.setWindowModality(Qt.WindowModality.ApplicationModal)
        progress.setMinimumDuration(0)
        progress.setAutoClose(False)
        progress.setAutoReset(False)
        progress.setValue(0)

        QApplication.processEvents()

        try:
            total_files = len(normalized)
            all_dfs = []
            total_reqs = 0

            for i, path in enumerate(normalized, 1):
                progress.setLabelText(f"Extracting from: {Path(path).name}")
                progress.setValue(0)
                QApplication.processEvents()

                def update_progress(pct):
                    progress.setLabelText(f"Loading {Path(path).name}... {pct}%")
                    progress.setValue(pct)
                    QApplication.processEvents()

                new_df = self.data_manager.load_word_documents([path], progress_callback=update_progress)
                all_dfs.append(new_df)

                req_count = new_df["Object Type"].str.lower().eq("requirement").sum()
                total_reqs += req_count

            df = pd.concat(all_dfs, ignore_index=True)
            df = self.data_manager.merge_new_dataframe(df)
            self._undo_stack = [df.copy()]

            progress.setLabelText("Finalizing traceability...")
            progress.setValue(100)
            QApplication.processEvents()

            self.populate_table()

            QMessageBox.information(
                self,
                "Requirements Loaded",
                f"✅ {total_reqs} requirements loaded successfully."
            )

        except RequirementDataError as exc:
            LOGGER.exception("Failed to load Word documents")
            QMessageBox.critical(self, "Load Error", str(exc))
        finally:
            progress.close()



    # ------------------------------------------------------------------
    def load_excels(self) -> None:
        files, _ = QFileDialog.getOpenFileNames(
            self, "Select Excel Files", "", "Excel Files (*.xlsx *.xls *.xlsm *.xlsb)"
        )
        if not files:
            return
        ordered = self._show_reorder_dialog(files)
        if not ordered:
            return

        # Copy into project, then import from the local copies
        local_paths = self._copy_into_project(ordered)
        if not local_paths:
            return
        self._import_excel_files(local_paths)

        # Persist metadata/state
        self._save_project_metadata(excel_files=local_paths)
        self._save_project_state()
        self.log_console("Excel files saved to project metadata.")

    def load_word_documents(self) -> None:
        pattern = self._prompt_requirement_pattern()
        if pattern is None:
            return
        files, _ = QFileDialog.getOpenFileNames(
            self, "Select Word Files", "", "Word Documents (*.docx *.docm)"
        )
        if not files:
            return

        # Copy into project, then import from the local copies
        local_paths = self._copy_into_project(files)
        if not local_paths:
            return
        self._import_word_files(local_paths, pattern)

        # Persist metadata/state
        self._save_project_metadata(word_files=local_paths, word_pattern=pattern)
        self._save_project_state()
        self.log_console("Word files saved to project metadata.")



    # ------------------------------------------------------------------
    def dragEnterEvent(self, event) -> None:
        if event.mimeData().hasUrls():
            for url in event.mimeData().urls():
                if not url.isLocalFile():
                    continue
                ext = Path(url.toLocalFile()).suffix.lower()
                if ext in {".xls", ".xlsx", ".xlsm", ".xlsb", ".docx", ".docm"}:
                    event.acceptProposedAction()
                    return
        event.ignore()

    # ------------------------------------------------------------------
    def dropEvent(self, event) -> None:
        if not event.mimeData().hasUrls():
            event.ignore()
            return

        excel_files: list[str] = []
        word_files: list[str] = []
        unsupported: list[str] = []

        for url in event.mimeData().urls():
            if not url.isLocalFile():
                continue
            path = Path(url.toLocalFile())
            if not path.exists():
                continue
            ext = path.suffix.lower()
            if ext in {".xls", ".xlsx", ".xlsm", ".xlsb"}:
                excel_files.append(str(path))
            elif ext in {".docx", ".docm"}:
                word_files.append(str(path))
            elif ext in {".doc"}:
                unsupported.append(str(path))

        if not excel_files and not word_files:
            if unsupported:
                QMessageBox.warning(
                    self,
                    "Unsupported Files",
                    "The following files are not supported:\n" + "\n".join(unsupported),
                )
            event.ignore()
            return

        pattern_config: Optional[dict[str, str]] = None
        if word_files:
            pattern_config = self._prompt_requirement_pattern()
            if pattern_config is None:
                word_files = []

        if excel_files:
            ordered = self._show_reorder_dialog(excel_files)
            if ordered:
                self._import_excel_files(ordered)
        if word_files:
            self._import_word_files(word_files, pattern_config)
        if unsupported:
            QMessageBox.warning(
                self,
                "Unsupported Files",
                "The following files are not supported:\n" + "\n".join(unsupported),
            )
        event.acceptProposedAction()

    # ------------------------------------------------------------------
    def dragMoveEvent(self, event) -> None:
        self.dragEnterEvent(event)

    # ------------------------------------------------------------------
    def populate_table(self) -> None:
        df = self.data_manager.dataframe
        base_columns = self.data_manager.visible_columns

        self._loading = True
        self.table_tabs.blockSignals(True)
        self.table_tabs.clear()
        self._tab_tables.clear()
        self._tab_indices.clear()
        self._tab_source_types.clear()

        if df.empty or not base_columns:
            placeholder = self._create_table_widget()
            placeholder.setEnabled(False)
            placeholder.setRowCount(0)
            placeholder.setColumnCount(len(base_columns))
            if base_columns:
                placeholder.setHorizontalHeaderLabels(base_columns)
            self.table_tabs.addTab(placeholder, "No Data")
            self.table_tabs.blockSignals(False)
            self._loading = False
            self.view_stack.setCurrentWidget(self.table_tabs) if self.project_name else self.view_stack.setCurrentWidget(self.front_page)
            self.populate_navigation()
            return

        tab_groups: list[tuple[str, pd.DataFrame, str]] = []
        if "SourceType" in df.columns:
            type_series = df["SourceType"].astype(str).str.lower()
            excel_mask = type_series == "excel"
            if excel_mask.any():
                tab_groups.append(("Excel", df[excel_mask], "excel"))
            word_mask = type_series.isin({"word", "doc", "docx", "docm"})
            if word_mask.any():
                for source, group in df[word_mask].groupby("SourceFile", sort=False):
                    tab_groups.append(
                        (str(source).strip() or "Word Document", group, "docx")
                    )
            other_mask = ~(excel_mask | word_mask)
            if other_mask.any():
                for source, group in df[other_mask].groupby("SourceFile", sort=False):
                    stype = (
                        str(group["SourceType"].iloc[0]).lower()
                        if "SourceType" in group.columns
                        else "manual"
                    )
                    tab_groups.append((str(source).strip() or "Data", group, stype))
        else:
            for source, group in df.groupby("SourceFile", sort=False):
                tab_groups.append((str(source).strip() or "Data", group, "manual"))

        if not tab_groups:
            placeholder = self._create_table_widget()
            placeholder.setEnabled(False)
            placeholder.setRowCount(0)
            placeholder.setColumnCount(len(base_columns))
            if base_columns:
                placeholder.setHorizontalHeaderLabels(base_columns)
            self.table_tabs.addTab(placeholder, "No Data")
            self.table_tabs.blockSignals(False)
            self._loading = False
            self.view_stack.setCurrentWidget(self.table_tabs)
            self.populate_navigation()
            return

        for source_name, group, source_type in tab_groups:
            table = self._create_table_widget()
            table.setProperty("source", source_name)
            table.setProperty("source_type", source_type)
            
            # Excel-style header menu on this table
            header = table.horizontalHeader()
            header.setSectionsClickable(True)
            header.sectionClicked.connect(lambda idx, t=table: self._on_table_header_clicked(t, idx))
            QShortcut(QKeySequence("Alt+Down"), table, activated=lambda t=table: self._open_table_header_menu(t))

            # Apply filters/sort for this tab before painting rows
            display_df = self._apply_table_filters(source_name, group, base_columns)
            display_df = self._apply_table_sort(source_name, display_df, base_columns)

            table.setRowCount(len(display_df))
            table.setColumnCount(len(base_columns))
            table.setHorizontalHeaderLabels(base_columns)
            table.horizontalHeader().setStretchLastSection(True)

            row_indices = display_df.index.tolist()
            self._tab_tables[source_name] = table
            self._tab_indices[source_name] = row_indices
            self._tab_source_types[source_name] = source_type
            self._ensure_header_profile(source_name)

            for display_row, (df_index, row) in enumerate(display_df.iterrows()):
                is_heading = "heading" in str(row.get("Object Type", "")).lower()
                for column_index, column_name in enumerate(base_columns):
                    normalized_column = column_name.strip().lower()
                    raw_value = row.get(column_name, "")
                    if pd.isna(raw_value):
                        raw_value = ""
                    value = str(raw_value)

                    # Excel-like Object Type dropdown
                    if normalized_column == "object type":
                        self._set_object_type_cell(table, display_row, df_index, value)
                        continue

                    
                    if normalized_column == "object text":
                        item = QTableWidgetItem(value)
                        item.setData(Qt.ItemDataRole.UserRole, df_index)
                        item.setTextAlignment(
                            Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft
                        )
                        flags = Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
                        text_widget = self._create_text_cell_widget(
                            row, df_index, column_name
                        )
                        if text_widget is None:
                            flags |= Qt.ItemFlag.ItemIsEditable
                        item.setFlags(flags)
                        table.setItem(display_row, column_index, item)
                        if text_widget is not None:
                            table.setCellWidget(display_row, column_index, text_widget)
                            hint = text_widget.sizeHint()
                            target_height = max(
                                table.rowHeight(display_row), hint.height() + 8
                            )
                            table.setRowHeight(display_row, target_height)
                        continue

                    item = QTableWidgetItem(value)
                    if is_heading:
                        font = item.font()
                        font.setBold(True)
                        item.setFont(font)
                    if normalized_column == "up trace" and value.strip():
                        font = item.font()
                        font.setUnderline(True)
                        item.setFont(font)
                        item.setForeground(Qt.GlobalColor.blue)
                        item.setToolTip("Double-click to open in Traceability Matrix")
                    elif normalized_column in {"requirement id","req id","reqid"} and value.strip():
                        font = item.font()
                        font.setUnderline(True)
                        item.setFont(font)
                        item.setForeground(Qt.GlobalColor.blue)
                        item.setToolTip("Double-click to open in Traceability Matrix")
                    item.setTextAlignment(
                        Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft
                    )
                    item.setData(Qt.ItemDataRole.UserRole, df_index)
                    table.setItem(display_row, column_index, item)
            table.resizeColumnsToContents()
            table.resizeRowsToContents()
            self.table_tabs.addTab(table, source_name)

        self.table_tabs.blockSignals(False)
        self._loading = False
        self.view_stack.setCurrentWidget(self.table_tabs)
        self._ensure_header_profile(self._current_source_name())
        self.log_console("Table populated with Excel-style formatting.")
        self.populate_navigation()

    # ------------------------------------------------------------------
    def _format_attachment_preview(self, row: pd.Series) -> str:
        att_type = str(row.get("Attachment Type", "") or "").strip().lower()
        data = row.get("Attachment Data", "")
        if not att_type:
            return ""
        if pd.isna(data):
            data = ""
        data_str = str(data).strip()
        if not data_str:
            return att_type.capitalize() if att_type else ""

        if att_type == "table":
            preview_lines: list[str] = []
            try:
                from bs4 import BeautifulSoup  # type: ignore
            except Exception:
                BeautifulSoup = None

            if BeautifulSoup:
                soup = BeautifulSoup(data_str, "html.parser")
                rows = soup.find_all("tr")
                total_rows = len(rows)
                total_cols = max(
                    (len(r.find_all(["td", "th"])) for r in rows), default=0
                )
                if total_rows and total_cols:
                    preview_lines.append(f"Table ({total_rows} x {total_cols})")
                for row_tag in rows[:5]:
                    cells = [
                        cell.get_text(separator=" ", strip=True)
                        for cell in row_tag.find_all(["td", "th"])
                    ]
                    if cells:
                        preview_lines.append(" | ".join(cells))
                if total_rows > 5:
                    preview_lines.append("…")

            if not preview_lines:
                stripped = self._strip_html_to_text(data_str)
                if stripped:
                    preview_lines.append(stripped)

            return "\n".join(preview_lines[:6])

        if att_type == "image":
            filename = ""
            mime = ""
            try:
                payload = json.loads(data_str)
                filename = str(payload.get("filename", "") or "").strip()
                mime = str(payload.get("mime", "") or "").strip()
            except Exception:
                pass
            descriptor = filename or mime or "image"
            return f"Image: {descriptor}"

        label = att_type.capitalize()
        if len(data_str) <= 160:
            return data_str
        return f"{label} attachment"

    # ------------------------------------------------------------------
    def _create_attachment_widget(
        self, row: pd.Series, tooltip: str
    ) -> QWidget | None:
        att_type = str(row.get("Attachment Type", "") or "").strip().lower()
        if not att_type:
            return None
        data = row.get("Attachment Data", "")
        if pd.isna(data):
            data = ""
        data_str = str(data).strip()
        if not data_str:
            return None

        if att_type == "image":
            return self._create_image_preview_widget(data_str, tooltip)
        if att_type == "table":
            return self._create_table_preview_widget(data_str, tooltip)
        return None

    # ------------------------------------------------------------------
    def _create_image_preview_widget(self, payload: str, tooltip: str) -> QWidget | None:
        encoded = ""
        filename = ""
        try:
            payload_data = json.loads(payload)
            encoded = str(payload_data.get("data", "") or "")
            filename = str(payload_data.get("filename", "") or "")
        except json.JSONDecodeError:
            encoded = payload

        if not encoded:
            return None
        try:
            image_bytes = base64.b64decode(encoded)
        except (ValueError, binascii.Error, AttributeError):
            return None

        image = QImage.fromData(image_bytes)
        if image.isNull():
            return None

        pixmap = QPixmap.fromImage(image)
        max_width = 360
        max_height = 240
        scaled = pixmap.scaled(
            max_width,
            max_height,
            Qt.AspectRatioMode.KeepAspectRatio,
            Qt.TransformationMode.SmoothTransformation,
        )

        label = QLabel()
        label.setPixmap(scaled)
        label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        label.setScaledContents(False)
        label.setSizePolicy(
            QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred
        )
        label.setMinimumSize(scaled.size())
        label.setMaximumSize(max_width + 16, max_height + 16)
        label.setStyleSheet("padding: 4px;")
        tooltip_text = tooltip or filename or "Image attachment"
        label.setToolTip(tooltip_text)
        return label

    def closeEvent(self, event):
        """Automatically save Excel and Word files when window closes."""
        try:
            if hasattr(self, "project_path") and self.project_path:
                # Save Excel
                excel_path = os.path.join(self.project_path, "data.xlsx")
                if hasattr(self, "data_manager") and hasattr(self.data_manager, "save_excel"):
                    self.data_manager.save_excel(excel_path)
                # Save Word
                word_path = os.path.join(self.project_path, "output.docx")
                if hasattr(self, "word_manager") and hasattr(self.word_manager, "save_word"):
                    self.word_manager.save_word(word_path)
                # Update metadata timestamp
                if hasattr(self, "_save_project_metadata"):
                    self._save_project_metadata()
            if hasattr(self, "log_console"):
                self.log_console(f"Project '{self.project_name}' autosaved on close.")
        except Exception as e:
            if hasattr(self, "log_console"):
                self.log_console(f"Auto-save failed: {e}")
        self._save_project_state()
        super().closeEvent(event)


    # ------------------------------------------------------------------
    def _create_table_preview_widget(
        self, html_table: str, tooltip: str
    ) -> QWidget | None:
        table_widget: QWidget | None = None
        try:
            from bs4 import BeautifulSoup  # type: ignore
        except Exception:
            BeautifulSoup = None

        rows = []
        if BeautifulSoup:
            soup = BeautifulSoup(html_table, "html.parser")
            rows = soup.find_all("tr")

        if rows:
            max_cols = max(len(row.find_all(["td", "th"])) for row in rows) or 1
            table_widget = QTableWidget(len(rows), max_cols)
            table_widget.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
            table_widget.horizontalHeader().setVisible(False)
            table_widget.verticalHeader().setVisible(False)
            table_widget.setShowGrid(True)
            table_widget.setSizePolicy(
                QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Minimum
            )
            table_widget.setStyleSheet("QTableWidget { gridline-color: #888; }")

            for row_idx, row_tag in enumerate(rows):
                cells = row_tag.find_all(["td", "th"])
                for col_idx, cell in enumerate(cells):
                    if col_idx >= max_cols:
                        break
                    text = cell.get_text(separator="\n").strip()
                    cell_item = QTableWidgetItem(text)
                    cell_item.setFlags(
                        Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
                    )
                    table_widget.setItem(row_idx, col_idx, cell_item)

            table_widget.resizeColumnsToContents()
            table_widget.resizeRowsToContents()
            header_length = table_widget.horizontalHeader().length()
            width = min(max(header_length + 12, 180), 520)
            table_widget.setMinimumWidth(width)
            table_widget.setMaximumWidth(520)
            content_height = table_widget.verticalHeader().length() or (
                table_widget.rowCount() * table_widget.rowHeight(0)
            )
            height = min(content_height + 12, 320)
            table_widget.setMinimumHeight(height)
            table_widget.setMaximumHeight(320)
        else:
            text = self._strip_html_to_text(html_table)
            if not text:
                return None
            label = QLabel(text)
            label.setWordWrap(True)
            label.setAlignment(
                Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop
            )
            label.setSizePolicy(
                QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Minimum
            )
            label.setStyleSheet("padding: 4px; border: 1px solid #CCCCCC;")
            label.setMinimumWidth(200)
            table_widget = label

        if table_widget is not None and tooltip:
            table_widget.setToolTip(tooltip)
        return table_widget

    # ------------------------------------------------------------------
    def _strip_html_to_text(self, html_text: str) -> str:
        if not html_text:
            return ""
        text = html.unescape(re.sub(r"<[^>]+>", " ", html_text))
        return re.sub(r"\s+", " ", text).strip()

    # ------------------------------------------------------------------
    def _create_text_cell_widget(
        self, row: pd.Series, df_index: int, column_name: str
    ) -> QWidget | None:
        text_value = str(row.get(column_name, "") or "")
        tooltip = self._format_attachment_preview(row)
        attachment_widget = self._create_attachment_widget(row, tooltip)

        if attachment_widget is None:
            return None

        container = QWidget()
        container.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Minimum)
        layout = QVBoxLayout(container)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(6)

        if text_value:
            label = QLabel(text_value)
            label.setWordWrap(True)
            label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)
            label.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Minimum)
            label.setStyleSheet("padding: 4px;")
            layout.addWidget(label)

        layout.addWidget(attachment_widget)
        return container

    # ------------------------------------------------------------------
    def populate_navigation(self) -> None:
        self.nav_tree.clear()
        subset = self._get_dataframe_for_source(raw=True)
        if subset.empty:
            return
        current_h1: QTreeWidgetItem | None = None
        current_h2: QTreeWidgetItem | None = None
        for global_index, row in subset.iterrows():
            obj_type = str(row.get("Object Type", "")).strip().lower()
            section = str(row.get(self.data_manager.section_column_name, "")).strip()
            text = str(row.get("Object Text", "")).strip()
            if not text:
                continue
            label = f"{section} {text}".strip()
            payload = {
                "index": int(global_index),
                "section": section,
                "text": text,
                "type": obj_type,
                "anchor": f"row-{global_index}",
            }
            if obj_type == "heading 1":
                current_h1 = QTreeWidgetItem([label])
                current_h1.setData(0, Qt.ItemDataRole.UserRole, payload)
                self.nav_tree.addTopLevelItem(current_h1)
                current_h2 = None
            elif obj_type == "heading 2":
                if current_h1 is None:
                    continue
                current_h2 = QTreeWidgetItem([label])
                current_h2.setData(0, Qt.ItemDataRole.UserRole, payload)
                current_h1.addChild(current_h2)
            elif obj_type == "heading 3":
                if current_h2 is None:
                    continue
                item = QTreeWidgetItem([label])
                item.setData(0, Qt.ItemDataRole.UserRole, payload)
                current_h2.addChild(item)
        self.nav_tree.expandAll()

    # ------------------------------------------------------------------
    def on_nav_item_clicked(self, item: QTreeWidgetItem) -> None:
        payload = item.data(0, Qt.ItemDataRole.UserRole) or {}
        global_index = payload.get("index")
        text_value = payload.get("text") or item.text(0).split(" ", 1)[-1].strip()
        section_value = payload.get("section", "")
        anchor_id = payload.get("anchor")
        desired_source = None

        if global_index is not None and global_index in self.data_manager.dataframe.index:
            row = self.data_manager.dataframe.loc[global_index]
            desired_source = str(row.get("SourceFile", "")).strip() or "Manual"
            source_type = str(row.get("SourceType", "")).strip().lower()
            if source_type == "excel" and "Excel" in self._tab_source_types:
                desired_source = "Excel"
            self._select_source_tab(desired_source)
            if self.view_stack.currentWidget() is self.word_preview:
                self.update_word_preview()
            elif self.view_stack.currentWidget() is self.table_tabs:
                self._select_global_row(desired_source, int(global_index))
                table = self._tab_tables.get(desired_source)
                if table:
                    table.setFocus()

        target_candidates = [
            f"{section_value} {text_value}".strip(),
            text_value,
            item.text(0).strip(),
        ]
        if self.view_stack.currentWidget() is self.word_preview:
            def navigate_preview(
                anchor=anchor_id,
                candidates=tuple(target_candidates),
                fallback=text_value,
            ) -> None:
                if anchor:
                    self.word_preview.scrollToAnchor(anchor)
                matched = self._highlight_preview_text(candidates)
                if matched:
                    self.log_console(f"Navigated to: {matched}")
                else:
                    self.log_console(f"Could not find heading: {fallback}")

            QTimer.singleShot(0, navigate_preview)
            return

        self.log_console(f"Navigated to: {text_value}")

    # ------------------------------------------------------------------
    def on_table_tab_changed(self, index: int) -> None:
        if self._loading:
            return
        self._ensure_header_profile(self._current_source_name())
        self.populate_navigation()
        if (
            self.view_stack.currentWidget() is self.word_preview
            and not self._get_dataframe_for_source().empty
        ):
            self.update_word_preview()

    # ------------------------------------------------------------------
    def on_table_cell_changed(self, item: QTableWidgetItem) -> None:
        if self._loading:
            return
        table = item.tableWidget()
        if not isinstance(table, QTableWidget):
            return
        original_index = item.data(Qt.ItemDataRole.UserRole)
        if original_index is None:
            return
        column_header = table.horizontalHeaderItem(item.column())
        if column_header is None:
            return
        column_name = column_header.text()
        if column_name not in self.data_manager.dataframe.columns:
            return

        try:
            self.data_manager.update_cell(int(original_index), column_name, item.text().strip())
        except RequirementDataError as exc:
            QMessageBox.warning(self, "Edit Error", str(exc))
            self._loading = True
            try:
                previous_value = self.data_manager.dataframe.at[int(original_index), column_name]
                item.setText(str(previous_value))
            finally:
                self._loading = False
            return

        refreshed = self.data_manager.refresh_dataframe()
        self._undo_stack.append(refreshed.copy())
        self.populate_table()
        self._save_project_state()

    # ------------------------------------------------------------------
    def table_context_menu(self, table: QTableWidget, position) -> None:
        if table is None:
            return
        menu = QMenu(self)
        add_row = menu.addAction("Add Row Below")
        delete_row = menu.addAction("Delete Row")
        action = menu.exec(table.viewport().mapToGlobal(position))

        if action is None:
            return

        source = str(table.property("source") or "")
        source_type = str(
            table.property("source_type")
            or self._tab_source_types.get(source, "manual")
        )
        if action == add_row:
            insert_at = self._calculate_insert_position(table, insert_after=True)
            self._insert_blank_row(source, insert_at, source_type)
        elif action == delete_row:
            indices = self._tab_indices.get(source, [])
            current_row = table.currentRow()
            if 0 <= current_row < len(indices):
                self._delete_rows([indices[current_row]])

    # ------------------------------------------------------------------
    def add_image_attachment(self) -> None:
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Image",
            "",
            "Image Files (*.png *.jpg *.jpeg *.bmp *.gif *.tif *.tiff)",
        )
        if not file_path:
            return

        try:
            data = Path(file_path).read_bytes()
        except OSError as exc:
            QMessageBox.critical(self, "Image Error", f"Could not read image: {exc}")
            return

        mime = mimetypes.guess_type(file_path)[0] or "image/png"
        payload = {
            "mime": mime,
            "data": base64.b64encode(data).decode("ascii"),
            "filename": Path(file_path).name,
        }

        table = self._current_table()
        source = self._current_source_name() or "Manual"
        source_type = str(
            (table.property("source_type") if table else None)
            or self._tab_source_types.get(source, "manual")
        )
        insert_position = (
            self._calculate_insert_position(table, insert_after=True)
            if table is not None
            else len(self.data_manager.dataframe)
        )

        df = self.data_manager.insert_attachment(
            object_type="Image",
            attachment_type="image",
            attachment_data=json.dumps(payload),
            object_text=Path(file_path).name,
            insert_at=insert_position,
            source_file=source,
            sheet_name=self._default_sheet_name(source),
            source_type=source_type,
        )
        self._undo_stack.append(df.copy())
        self.populate_table()
        self._ensure_header_profile(source)
        self._select_global_row(source, insert_position)
        self.log_console(f"Image attachment added: {file_path}")
        self._save_project_state()

    # ------------------------------------------------------------------
    def add_table_attachment(self) -> None:
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Table File",
            "",
            "Table Files (*.xlsx *.xls *.csv)",
        )
        if not file_path:
            return

        suffix = Path(file_path).suffix.lower()
        try:
            if suffix in {".xlsx", ".xls"}:
                table_df = pd.read_excel(file_path)
            else:
                table_df = pd.read_csv(file_path)
        except Exception as exc:
            QMessageBox.critical(self, "Table Error", f"Could not load table: {exc}")
            return

        if table_df.empty:
            QMessageBox.information(self, "Empty Table", "Selected table has no data.")
            return

        caption, accepted = QInputDialog.getText(
            self, "Table Caption", "Caption (optional):"
        )
        if not accepted:
            return

        html_table = self.data_manager.dataframe_to_html_table(table_df)

        table = self._current_table()
        source = self._current_source_name() or "Manual"
        source_type = str(
            (table.property("source_type") if table else None)
            or self._tab_source_types.get(source, "manual")
        )
        insert_position = (
            self._calculate_insert_position(table, insert_after=True)
            if table is not None
            else len(self.data_manager.dataframe)
        )

        df = self.data_manager.insert_attachment(
            object_type="Table",
            attachment_type="table",
            attachment_data=html_table,
            object_text=caption.strip(),
            insert_at=insert_position,
            source_file=source,
            sheet_name=self._default_sheet_name(source),
            source_type=source_type,
        )
        self._undo_stack.append(df.copy())
        self.populate_table()
        self._ensure_header_profile(source)
        self._select_global_row(source, insert_position)
        self.log_console(f"Table attachment added: {file_path}")
        self._save_project_state()

    # ------------------------------------------------------------------
    def edit_header_details(self) -> None:
        source = self._current_source_name()
        self._ensure_header_profile(source)
        current_settings = self._get_header_settings(source)
        dialog = HeaderSettingsDialog(self, copy.deepcopy(current_settings))
        if dialog.exec() != QDialog.DialogCode.Accepted:
            return
        current_settings.update(dialog.values())
        self.log_console("Header details updated.")
        if self.view_stack.currentWidget() is self.word_preview:
            df = self._get_dataframe_for_source(source, raw=True)
            self.word_preview.setHtml(self.compose_preview_html(df))

    # ------------------------------------------------------------------
    def compose_preview_html(self, df: Optional[pd.DataFrame] = None) -> str:
        df_raw = df.copy() if df is not None else self._get_dataframe_for_source(raw=True)
        if df_raw.empty:
            local_df = pd.DataFrame()
        else:
            local_df = df_raw.reset_index().rename(columns={"index": "_global_index"})
        settings = self._get_header_settings()

        styles = """
        <style>
            body { font-family: Arial, sans-serif; font-size: 11pt; color: #000; margin: 20px; }
            .front-page { border: 2px solid #000; padding: 28px; margin-bottom: 36px; }
            .front-title { text-align: center; font-size: 18pt; font-weight: bold; margin-bottom: 12px; }
            .meta-lines { text-align: center; font-size: 12pt; margin-bottom: 16px; }
            .signature-table { width: 100%; border-collapse: collapse; margin-bottom: 18px; }
            .signature-table td, .signature-table th { border: 1px solid #000; padding: 6px; vertical-align: top; }
            .signature-table th { text-align: left; width: 22%; font-weight: bold; }
            .signature-name { font-weight: bold; }
            .signature-title { font-style: italic; font-size: 10pt; }
            .logo-row { display: flex; justify-content: space-between; align-items: center; margin: 20px 0; }
            .logo-cell { width: 48%; text-align: center; }
            .logo-cell img { max-height: 90px; }
            .address-row { display: flex; justify-content: space-between; }
            .address-block { width: 48%; text-align: left; line-height: 1.4; }
            .notice { border: 1px solid #000; padding: 12px; margin-top: 24px; }
            .notice-title { font-weight: bold; text-align: center; margin-bottom: 8px; }
            .copyright { text-align: center; margin-top: 18px; font-size: 10pt; }
            .page-separator { border-top: 2px solid #555; margin: 36px 0; }
            .toc-section { margin-bottom: 24px; }
            .toc-section h2 { font-size: 14pt; margin-bottom: 8px; }
            .toc-item { margin-left: 8px; line-height: 1.4; }
            .toc-item.level-2 { margin-left: 24px; }
            .toc-item.level-3 { margin-left: 40px; }
            .toc-item a { color: #000; text-decoration: none; }
            .toc-item a:hover { text-decoration: underline; }
            .requirement-id { font-weight: bold; margin-top: 16px; margin-bottom: 4px; }
            .requirement-text { margin-top: 0; text-align: left; line-height: 1.5; }
            .body-text { text-align: left; line-height: 1.5; margin-bottom: 12px; }
            table { margin: 12px auto; border-collapse: collapse; width: 100%; }
            table, td, th { border: 1px solid #000; padding: 4px; }
            .table-block { text-align: center; margin: 16px 0; }
            .image-block { text-align: center; margin: 16px 0; }
            .caption { font-style: italic; font-size: 10pt; margin-top: 6px; text-align: center; }
        </style>
        """

        front_page_html = self._build_front_page_html(settings)

        if local_df.empty:
            return f"<html><head>{styles}</head><body>{front_page_html}<p>No data loaded.</p></body></html>"

        toc_entries = []
        figure_entries = []
        table_entries = []
        body_parts: list[str] = []
        figure_count = 0
        table_count = 0
        section_col = self.data_manager.section_column_name

        for idx, row in local_df.iterrows():
            global_idx = row.get("_global_index", idx)
            obj_type = str(row.get("Object Type", "")).strip().lower()
            section = str(row.get(section_col, "")).strip()
            text = str(row.get("Object Text", "")).strip()
            req_id = str(row.get("Requirement ID", "")).strip()
            attachment_type = str(row.get("Attachment Type", "")).strip().lower()
            attachment_data = str(row.get("Attachment Data", "")).strip()

            if obj_type.startswith("heading"):
                level = int(obj_type.split()[-1])
                heading_text = f"{section} {text}".strip() or text or section or "Heading"
                heading_id = f"row-{global_idx}"
                body_parts.append(
                    f'<h{level} id="{heading_id}">{html.escape(heading_text)}</h{level}>'
                )
                toc_entries.append(
                    {"level": level, "id": heading_id, "title": heading_text}
                )
                continue

            if attachment_type == "table" and attachment_data:
                table_count += 1
                table_id = f"table-{global_idx}"
                caption_text = text or f"Table {table_count}"
                body_parts.append(f'<div id="{table_id}" class="table-block">{attachment_data}')
                body_parts.append(
                    f'<div class="caption">Table {table_count}: {html.escape(caption_text)}</div></div>'
                )
                table_entries.append(
                    {"id": table_id, "title": f"Table {table_count}: {caption_text}"}
                )
                continue

            if attachment_type == "image" and attachment_data:
                figure_count += 1
                figure_id = f"figure-{global_idx}"
                try:
                    payload = json.loads(attachment_data)
                except json.JSONDecodeError:
                    payload = {"data": attachment_data, "mime": "image/png", "filename": text or "Image"}
                image_data = payload.get("data", "")
                if not image_data:
                    continue
                mime = payload.get("mime", "image/png")
                caption_text = text or payload.get("filename", "") or f"Figure {figure_count}"
                width_percent = settings.get("preview_image_width_percent", 80)
                body_parts.append(
                    f'<div id="{figure_id}" class="image-block"><img src="data:{mime};base64,{image_data}" '
                    f'alt="{html.escape(caption_text)}" style="max-width:{width_percent}%; width:{width_percent}%; height:auto;"/></div>'
                )
                body_parts.append(
                    f'<div class="caption">Figure {figure_count}: {html.escape(caption_text)}</div>'
                )
                figure_entries.append(
                    {"id": figure_id, "title": f"Figure {figure_count}: {caption_text}"}
                )
                continue

            anchor_id = f"row-{global_idx}"
            if req_id:
                requirement_text = html.escape(text) if text else "&nbsp;"
                body_parts.append(
                    f'<div id="{anchor_id}" class="requirement-block">'
                    f'<p class="requirement-id">Requirement ID: {html.escape(req_id)}</p>'
                    f'<p class="requirement-text">{requirement_text}</p>'
                    "</div>"
                )
                continue

            if text:
                body_parts.append(
                    f'<p id="{anchor_id}" class="body-text">{html.escape(text)}</p>'
                )

        toc_html = ""
        if toc_entries:
            toc_html = '<div class="toc-section"><h2>Table of Contents</h2>'
            for entry in toc_entries:
                toc_html += (
                    f'<div class="toc-item level-{entry["level"]}">'
                    f'<a href="#{entry["id"]}">{html.escape(entry["title"])}</a>'
                    "</div>"
                )
            toc_html += "</div>"

        figures_html = ""
        if figure_entries:
            figures_html = '<div class="toc-section"><h2>List of Figures</h2><ol>'
            for entry in figure_entries:
                figures_html += (
                    f'<li><a href="#{entry["id"]}">{html.escape(entry["title"])}</a></li>'
                )
            figures_html += "</ol></div>"

        tables_html = ""
        if table_entries:
            tables_html = '<div class="toc-section"><h2>List of Tables</h2><ol>'
            for entry in table_entries:
                tables_html += (
                    f'<li><a href="#{entry["id"]}">{html.escape(entry["title"])}</a></li>'
                )
            tables_html += "</ol></div>"

        body_html = "\n".join(body_parts) if body_parts else "<p>No requirement content available.</p>"

        return (
            f"<html><head>{styles}</head><body>"
            f"{front_page_html}"
            '<div class="page-separator"></div>'
            f"{toc_html}{figures_html}{tables_html}{body_html}"
            "</body></html>"
        )

    # ------------------------------------------------------------------
    def _highlight_preview_text(self, candidates: Sequence[str]) -> Optional[str]:
        cursor = self.word_preview.textCursor()
        cursor.movePosition(QTextCursor.MoveOperation.End)
        self.word_preview.setTextCursor(cursor)
        for candidate in dict.fromkeys([c for c in candidates if c]):
            if self.word_preview.find(
                candidate, QTextDocument.FindFlag.FindBackward
            ):
                self.word_preview.ensureCursorVisible()
                return candidate
        return None

    # ------------------------------------------------------------------
    def _build_front_page_html(self, settings: Dict[str, object]) -> str:
        title = html.escape(str(settings.get("document_title", "Requirement Document")))
        doc_number = html.escape(str(settings.get("document_number", "")))
        revision = html.escape(str(settings.get("revision", "")))

        meta_lines = []
        if doc_number:
            meta_lines.append(f"Document No: {doc_number}")
        if revision:
            meta_lines.append(f"Revision: {revision}")
        meta_html = "<br/>".join(meta_lines)

        rows = []
        people = [
            ("Author", "author_name", "author_title"),
            ("Reviewer", "reviewer_name", "reviewer_title"),
            ("Quality Assurance", "qa_name", "qa_title"),
            ("Configuration Manager", "config_manager_name", "config_manager_title"),
        ]
        for label, name_key, title_key in people:
            name = str(settings.get(name_key, "")).strip()
            title_text = str(settings.get(title_key, "")).strip()
            name_html = html.escape(name) if name else "&nbsp;"
            title_html = html.escape(title_text) if title_text else ""
            cell_content = (
                f'<div class="signature-name">{name_html}</div>'
                + (f'<div class="signature-title">{title_html}</div>' if title_text else "")
            )
            rows.append(
                f"<tr><th>{label}:</th><td>{cell_content}</td><td>&nbsp;</td></tr>"
            )

        signature_table = (
            '<table class="signature-table">'
            + "".join(rows)
            + "</table>"
        )

        left_logo = self._logo_img_tag(str(settings.get("logo_left_path", "")), "Left Logo")
        right_logo = self._logo_img_tag(str(settings.get("logo_right_path", "")), "Right Logo")
        logo_row = ""
        if left_logo or right_logo:
            logo_row = (
                '<div class="logo-row">'
                f'<div class="logo-cell">{left_logo or ""}</div>'
                f'<div class="logo-cell">{right_logo or ""}</div>'
                "</div>"
            )

        address_howell = str(settings.get("address_howell", ""))
        address_mach = str(settings.get("address_mach", ""))
        addresses_html = ""
        if address_howell or address_mach:
            addresses_html = (
                '<div class="address-row">'
                f'<div class="address-block">{address_howell}</div>'
                f'<div class="address-block">{address_mach}</div>'
                "</div>"
            )

        notice_text = html.escape(str(settings.get("proprietary_notice", ""))).replace(
            "\n", "<br/>"
        )
        notice_html = (
            '<div class="notice">'
            '<div class="notice-title">Proprietary Notice</div>'
            f'<div class="notice-body">{notice_text}</div>'
            "</div>"
        )

        copyright_text = html.escape(str(settings.get("copyright_notice", "")))

        front_parts = [
            '<div class="front-page">',
            f'<div class="front-title">{title}</div>',
        ]
        if meta_html:
            front_parts.append(f'<div class="meta-lines">{meta_html}</div>')
        front_parts.append(signature_table)
        if logo_row:
            front_parts.append(logo_row)
        if addresses_html:
            front_parts.append(addresses_html)
        if copyright_text:
            front_parts.append(f'<div class="copyright">{copyright_text}</div>')
        front_parts.append(notice_html)
        front_parts.append("</div>")
        return "".join(front_parts)

    def clear_all_tabs(self, *, delete_files: bool = True):
        """Reset UI/memory and (optionally) delete on-disk files for THIS project.
        Removes files in both the canonical and legacy project folders.
        """
        import json, os, glob
        from pathlib import Path

        try:
            # --- UI + memory ---
            for attr in ("tab_widget", "table_tabs", "search_results", "nav_tree"):
                w = getattr(self, attr, None)
                try:
                    if w:
                        w.clear()
                except Exception:
                    pass
            try:
                if hasattr(self, "_tab_tables") and isinstance(self._tab_tables, dict):
                    self._tab_tables.clear()
            except Exception:
                pass

            if getattr(self, "data_manager", None):
                try:
                    empty_df = self.data_manager.create_empty_dataframe()
                    self.data_manager.dataframe = empty_df
                    try:
                        self._undo_stack = [empty_df.copy()]
                    except Exception:
                        self._undo_stack = []
                except Exception:
                    pass

            try:
                if hasattr(self, "populate_table"):
                    self.populate_table()
            except Exception:
                pass

            # --- Disk cleanup (both roots) ---
            if delete_files and getattr(self, "project_name", None):
                for proj_dir in both_project_dirs(self.project_name, __file__):
                    if not proj_dir.exists():
                        continue

                    # read metadata (to find copied Excel/Word basenames)
                    recorded = set()
                    meta_path = proj_dir / "project.json"
                    try:
                        if meta_path.exists():
                            meta = json.loads(meta_path.read_text(encoding="utf-8"))
                            for k in ("excel_files", "word_files"):
                                for f in (meta.get(k) or []):
                                    recorded.add(Path(str(f)).name)
                    except Exception:
                        pass

                    fixed = {"data.json", "data.xlsx", "output.docx", "project.json"}
                    for fname in sorted(fixed | recorded):
                        p = proj_dir / fname
                        try:
                            if p.exists():
                                os.remove(str(p))
                        except Exception:
                            pass

                    # sweep any strays not in metadata
                    try:
                        for pat in ("*.xls", "*.xlsx", "*.xlsm", "*.xlsb", "*.docx", "*.docm"):
                            for p in glob.glob(str(proj_dir / pat)):
                                try:
                                    os.remove(p)
                                except Exception:
                                    pass
                    except Exception:
                        pass

            try:
                self.header_profiles = {}
            except Exception:
                pass

            # write clean empty state so reopen is blank
            try:
                self._save_project_metadata(header_profiles={})
                self._save_project_state()
            except Exception:
                pass

            try:
                self.log_console("All project data cleared.")
            except Exception:
                pass

        except Exception as e:
            try:
                self.log_console(f"Failed to clear tabs: {e}")
            except Exception:
                pass


    # ------------------------------------------------------------------
    def _logo_img_tag(self, path: str, alt: str) -> str:
        if not path:
            return ""
        try:
            data = Path(path).read_bytes()
        except OSError:
            return ""
        mime = mimetypes.guess_type(path)[0] or "image/png"
        encoded = base64.b64encode(data).decode("ascii")
        return (
            f'<img src="data:{mime};base64,{encoded}" alt="{html.escape(alt)}" />'
        )

    # ------------------------------------------------------------------
    def update_word_preview(self) -> None:
        html_content = self.compose_preview_html()
        self.word_preview.setHtml(html_content)

    # ------------------------------------------------------------------
    def undo_last(self) -> None:
        if len(self._undo_stack) <= 1:
            return
        self._undo_stack.pop()
        self.data_manager.dataframe = self._undo_stack[-1].copy()
        self.populate_table()
        self.populate_navigation()
        self.log_console("Undo applied.")

    # ------------------------------------------------------------------
    # >>> REPLACE MainWindow.run_convert_preview
    def run_convert_preview(self):
        """
        When user clicks 'Run (Convert to Word)', use the DataFrame
        from the active Excel tab to generate the right-hand preview
        (and continue whatever conversion/export pipeline you already have).
        """
        tab = self._active_excel_tab()
        if not tab or tab.df is None or tab.df.empty:
            # Fallback to your previous behavior if no Excel tab selected
            # (If you want to disable fallback, just show a warning instead.)
            try:
                super().run_convert_preview()  # if old impl exists and is still desired
            except Exception:
                # Or inform the user:
                if hasattr(self, "log_console"):
                    self.log_console("No Excel tab selected or tab is empty.")
            return

        # Build HTML from the tab’s DF and show in your existing preview widget
        html = tab.build_preview_html()

        # If your main window has a QTextBrowser/QTextEdit preview area, set it here.
        # Common names I've seen in your code: self.word_preview / self.preview
        if hasattr(self, "word_preview") and self.word_preview is not None:
            self.word_preview.setHtml(html)
            # If you maintain anchors/navigation, do that here as well.
        elif hasattr(self, "preview") and self.preview is not None:
            self.preview.setHtml(html)

        # If you also export DOCX here, call your existing converter function with tab.df
        # Example:
        # self._export_df_to_docx(tab.df)
        # (Keep your original export/save flow unchanged; just feed it the DF from the tab.)


    # ------------------------------------------------------------------
    def show_table_view(self) -> None:
        self.view_stack.setCurrentWidget(self.table_tabs)
        self.log_console("Returned to table view.")

    
    def show_trace_view(self) -> None:
        """Switch to the Traceability Matrix view (with optional cross-tab selection).
        Cross-tab mode only shows *linked* requirement IDs (no gaps, no unrelated rows).
        """
        import re

        def _normalize_id(s: str) -> str:
            s = (s or "").strip()
            return re.sub(r"\s+", "", s).lower()

        def _looks_like_id(tok: str) -> bool:
            """Keep tokens that have at least one letter and one digit (REQ12, SWR-3, etc.)."""
            tok = tok.strip()
            return bool(tok) and any(c.isalpha() for c in tok) and any(c.isdigit() for c in tok)

        # Build list of open tab labels the user can select from
        open_tabs = [(name, name) for name in self._tab_tables.keys()]
        if open_tabs:
            dlg = TabSelectionDialog(open_tabs, self)
            if dlg.exec() == QDialog.DialogCode.Accepted:
                tab_ids = dlg.selected_tab_ids()
                if len(tab_ids) >= 2:
                    # Collect DataFrames for the selected tabs (raw indices)
                    frames = {tid: self._get_dataframe_for_source(tid, raw=True) for tid in tab_ids}

                    # ---- Build cross pairs *locally* (no dependency on data_manager.build_cross_pairs) ----
                    # Index requirements per tab -> {norm_id: (display_id, global_index)}
                    per_tab_index: dict[str, dict[str, tuple[str, int]]] = {}
                    for tab, df in frames.items():
                        if df is None or df.empty:
                            continue
                        # Keep only "Requirement" rows
                        mask = df["Object Type"].astype(str).str.lower().eq("requirement")
                        if not mask.any():
                            continue
                        index_map: dict[str, tuple[str, int]] = {}
                        for gidx, row in df[mask].iterrows():
                            rid = str(row.get("Requirement ID", "")).strip()
                            if not rid:
                                continue
                            key = _normalize_id(rid)
                            # prefer first occurrence
                            index_map.setdefault(key, (rid, int(gidx)))
                        per_tab_index[tab] = index_map

                    if len(per_tab_index) < 2:
                        QMessageBox.information(self, "Traceability Matrix",
                                                "The selected tabs do not contain requirements.")
                        return

                    # Build pair rows: only show rows where a requirement links (Up Trace) across tabs
                    row_maps: list[dict[str, str]] = []
                    row_sources: list[dict[str, dict[str, object]]] = []
                    seen = set()

                    for src_tab, df in frames.items():
                        if df is None or df.empty:
                            continue
                        mask = df["Object Type"].astype(str).str.lower().eq("requirement")
                        req_df = df[mask]
                        if req_df.empty:
                            continue
                        for gidx, row in req_df.iterrows():
                            src_id = str(row.get("Requirement ID", "")).strip()
                            if not src_id:
                                continue
                            up = str(row.get("Up Trace", "")).strip()
                            if not up:
                                continue
                            # Tokenize the Up Trace cell (commas, semicolons, whitespace, slashes, pipes)
                            tokens = [t for t in re.split(r"[\s,;/|]+", up) if _looks_like_id(t)]
                            if not tokens:
                                continue
                            for tok in tokens:
                                key = _normalize_id(tok)
                                for tgt_tab, idx_map in per_tab_index.items():
                                    if tgt_tab == src_tab:
                                        continue
                                    if key in idx_map:
                                        tgt_id, tgt_gidx = idx_map[key]
                                        serial = (src_tab, src_id.lower(), tgt_tab, tgt_id.lower())
                                        if serial in seen:
                                            continue
                                        seen.add(serial)

                                        # Build a "matrix row" with no gaps
                                        row_map = {tab: "" for tab in tab_ids}
                                        row_map[src_tab] = src_id
                                        row_map[tgt_tab] = tgt_id
                                        row_maps.append(row_map)

                                        # Sources used for navigation
                                        row_sources.append({
                                            src_tab: {"source": src_tab, "global_index": int(gidx), "req_id": src_id},
                                            tgt_tab: {"source": tgt_tab, "global_index": int(tgt_gidx), "req_id": tgt_id},
                                        })

                    if not row_maps:
                        QMessageBox.information(self, "Traceability Matrix",
                                                "No cross‑tab trace links found between the selected tabs.")
                        return

                    columns = tab_ids
                    rows_matrix = [[row.get(tab, "") for tab in columns] for row in row_maps]

                    # Hand off to the Trace Matrix view
                    try:
                        self.trace_view.load_pairs(columns, rows_matrix, row_sources)
                    except Exception as exc:
                        # Fallback: simple table rendering
                        import pandas as pd
                        df_pairs = pd.DataFrame(rows_matrix, columns=columns)
                        try:
                            self.trace_view.load_data(df_pairs)
                        except Exception:
                            QMessageBox.critical(self, "Traceability Matrix", f"Failed to display pairs: {exc}")
                            return

                    self.view_stack.setCurrentWidget(self.trace_view)
                    self.log_console(f"Cross trace built for tabs: {', '.join(tab_ids)} "
                                    f"({len(rows_matrix)} linked row(s)).")
                    return

        # Fallback: existing single-dataset matrix
        self._switch_to_trace_view()

    # ------------------------------------------------------------------
    def save_word(self) -> None:
        df = self._get_dataframe_for_source(raw=True)
        if df.empty:
            QMessageBox.warning(self, "Empty", "Nothing to save!")
            return

        file_name, _ = QFileDialog.getSaveFileName(
            self, "Save Word File", "", "Word Document (*.docx)"
        )
        if not file_name:
            return
        if not file_name.endswith(".docx"):
            file_name += ".docx"

        try:
            from docx import Document
            from docx.enum.table import WD_TABLE_ALIGNMENT
            from docx.enum.text import (
                WD_ALIGN_PARAGRAPH,
                WD_TAB_ALIGNMENT,
                WD_TAB_LEADER,
            )
            from docx.oxml import OxmlElement, parse_xml
            from docx.oxml.ns import qn, nsdecls
            from docx.shared import Inches, Pt, RGBColor
            from bs4 import BeautifulSoup
        except Exception as exc:  # pragma: no cover - optional dependency
            QMessageBox.critical(
                self,
                "Dependency Error",
                "python-docx and beautifulsoup4 are required to export Word files.\n"
                f"Details: {exc}",
            )
            return

        settings = self._get_header_settings()
        document = Document()
        self._configure_document_template(
            document, settings, Pt, Inches, OxmlElement, qn
        )
        self._build_header_footer(
            document,
            settings,
            WD_ALIGN_PARAGRAPH,
            WD_TAB_ALIGNMENT,
            WD_TAB_LEADER,
            Pt,
            Inches,
            OxmlElement,
            qn,
            parse_xml,
            nsdecls,
        )
        self._add_front_matter(
            document,
            settings,
            WD_ALIGN_PARAGRAPH,
            Pt,
            Inches,
            WD_TABLE_ALIGNMENT,
            OxmlElement,
            qn,
        )
        document.add_page_break()
        self._add_table_of_contents(document, settings, OxmlElement, qn)
        document.add_page_break()
        self._append_body_content(
            document,
            df,
            settings,
            BeautifulSoup,
            WD_ALIGN_PARAGRAPH,
            Inches,
            WD_TABLE_ALIGNMENT.CENTER,
            OxmlElement,
            qn,
            RGBColor,
        )
        document.save(file_name)
        self.log_console(
            f"Word file saved: {file_name} (update fields in Word to refresh TOC)"
        )

    # ------------------------------------------------------------------
    def _configure_document_template(
        self, document, settings, Pt, Inches, OxmlElement, qn
    ) -> None:
        section = document.sections[0]
        section.top_margin = Inches(1)
        section.bottom_margin = Inches(1)
        section.left_margin = Inches(1)
        section.right_margin = Inches(1)

        self._apply_page_border(section, OxmlElement, qn)

        normal_style = document.styles["Normal"]
        normal_style.font.name = "Arial"
        normal_style.font.size = Pt(11)

        for style_name, size in (("Heading 1", 12), ("Heading 2", 12), ("Heading 3", 11)):
            style = document.styles[style_name]
            style.font.name = "Arial"
            style.font.size = Pt(size)
            style.font.bold = True

    # ------------------------------------------------------------------
    def _apply_page_border(self, section, OxmlElement, qn) -> None:
        sect_pr = section._sectPr
        existing = sect_pr.find(qn("w:pgBorders"))
        if existing is not None:
            sect_pr.remove(existing)

        page_borders = OxmlElement("w:pgBorders")
        page_borders.set(qn("w:offsetFrom"), "page")
        for edge in ("top", "left", "bottom", "right"):
            border = OxmlElement(f"w:{edge}")
            border.set(qn("w:val"), "single")
            border.set(qn("w:sz"), "12")
            border.set(qn("w:space"), "24")
            border.set(qn("w:color"), "000000")
            page_borders.append(border)
        sect_pr.append(page_borders)

    # ------------------------------------------------------------------
    def _build_header_footer(
        self,
        document,
        settings,
        WD_ALIGN_PARAGRAPH,
        WD_TAB_ALIGNMENT,
        WD_TAB_LEADER,
        Pt,
        Inches,
        OxmlElement,
        qn,
        parse_xml,
        nsdecls,
    ) -> None:
        section = document.sections[0]

        header = section.header
        header.is_linked_to_previous = False
        header_para = header.paragraphs[0]
        header_para.text = ""

        doc_number = str(settings.get("document_number", ""))
        title = str(settings.get("document_title", ""))
        revision = str(settings.get("revision", ""))
        core_parts = [part for part in (doc_number, title) if part]
        if revision:
            header_text = " \u2013 ".join(core_parts)
            if header_text:
                header_text = f"{header_text} - Revision: {revision}"
            else:
                header_text = f"Revision: {revision}"
        else:
            header_text = " \u2013 ".join(core_parts)
        if not header_text:
            header_text = "Requirement Document"
        header_run = header_para.add_run(header_text)
        header_run.font.name = "Arial"
        header_run.font.size = Pt(10)
        header_para.alignment = WD_ALIGN_PARAGRAPH.CENTER

        footer = section.footer
        footer.is_linked_to_previous = False
        footer_para = footer.paragraphs[0]
        footer_para.text = ""
        paragraph_format = footer_para.paragraph_format
        paragraph_format.tab_stops.clear_all()
        paragraph_format.tab_stops.add_tab_stop(
            Inches(3.5), WD_TAB_ALIGNMENT.CENTER, WD_TAB_LEADER.SPACES
        )
        paragraph_format.tab_stops.add_tab_stop(
            Inches(7.0), WD_TAB_ALIGNMENT.RIGHT, WD_TAB_LEADER.SPACES
        )
        paragraph_format.space_before = Pt(6)
        paragraph_format.space_after = Pt(0)

        left_run = footer_para.add_run("Mach Global Technologies       ")
        left_run.font.name = "Arial"
        footer_para.add_run("\t")
        center_run = footer_para.add_run("Howell Instruments Proprietary Information")
        center_run.font.name = "Arial"
        footer_para.add_run("\tPage ")
        self._append_page_field(footer_para, OxmlElement, qn)
        watermark_text = str(settings.get("watermark_text", "")).strip()
        if watermark_text:
            self._apply_watermark(document, watermark_text, parse_xml, nsdecls)


    # ------------------------------------------------------------------
    def _append_page_field(self, paragraph, OxmlElement, qn) -> None:
        field = OxmlElement("w:fldSimple")
        field.set(qn("w:instr"), "PAGE")
        paragraph._p.append(field)

    # ------------------------------------------------------------------
    def _add_front_matter(
        self,
        document,
        settings,
        WD_ALIGN_PARAGRAPH,
        Pt,
        Inches,
        WD_TABLE_ALIGNMENT,
        OxmlElement,
        qn,
    ) -> None:
        title = settings.get("document_title") or "Requirement Document"
        doc_number = settings.get("document_number")
        revision = settings.get("revision")

        title_para = document.add_paragraph()
        title_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
        title_run = title_para.add_run(title)
        title_run.bold = True
        title_run.font.name = "Arial"
        title_run.font.size = Pt(18)

        if doc_number:
            doc_para = document.add_paragraph()
            doc_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
            doc_run = doc_para.add_run(f"Document No: {doc_number}")
            doc_run.font.name = "Arial"
            doc_run.font.size = Pt(12)

        if revision:
            rev_para = document.add_paragraph()
            rev_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
            rev_run = rev_para.add_run(f"Revision: {revision}")
            rev_run.font.name = "Arial"
            rev_run.font.size = Pt(12)

        document.add_paragraph()

        roles = [
            ("Author", "author_name", "author_title"),
            ("Reviewer", "reviewer_name", "reviewer_title"),
            ("Quality Assurance", "qa_name", "qa_title"),
            ("Configuration Manager", "config_manager_name", "config_manager_title"),
        ]
        table = document.add_table(rows=len(roles), cols=3)
        table.style = "Table Grid"
        table.alignment = WD_TABLE_ALIGNMENT.CENTER
        for row_idx, (label, name_key, title_key) in enumerate(roles):
            cells = table.rows[row_idx].cells
            cells[0].text = f"{label}:"
            for run in cells[0].paragraphs[0].runs:
                run.font.bold = True
            name = str(settings.get(name_key, "")).strip()
            title_text = str(settings.get(title_key, "")).strip()
            cell_lines = []
            if name:
                cell_lines.append(name)
            if title_text:
                cell_lines.append(title_text)
            cells[1].text = "\n".join(cell_lines)
            cells[2].text = ""

        document.add_paragraph()

        logo_table = document.add_table(rows=1, cols=2)
        logo_table.alignment = WD_TABLE_ALIGNMENT.CENTER
        self._clear_table_borders(logo_table, OxmlElement, qn)
        for idx, key in enumerate(("logo_left_path", "logo_right_path")):
            cell = logo_table.cell(0, idx)
            paragraph = cell.paragraphs[0]
            paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
            self._insert_logo(
                paragraph,
                str(settings.get(key, "")),
                Inches,
            )

        document.add_paragraph()

        address_table = document.add_table(rows=1, cols=2)
        address_table.alignment = WD_TABLE_ALIGNMENT.CENTER
        self._clear_table_borders(address_table, OxmlElement, qn)
        address_howell = str(settings.get("address_howell", "")).replace("<br/>", "\n")
        address_mach = str(settings.get("address_mach", "")).replace("<br/>", "\n")
        address_table.cell(0, 0).text = address_howell
        address_table.cell(0, 1).text = address_mach

        document.add_paragraph()

        copyright_text = str(settings.get("copyright_notice", "")).strip()
        if copyright_text:
            copyright_para = document.add_paragraph(copyright_text)
            copyright_para.alignment = WD_ALIGN_PARAGRAPH.CENTER

        notice_table = document.add_table(rows=2, cols=1)
        notice_table.style = "Table Grid"
        notice_table.alignment = WD_TABLE_ALIGNMENT.CENTER
        notice_table.cell(0, 0).text = "Proprietary Notice"
        notice_table.cell(0, 0).paragraphs[0].alignment = WD_ALIGN_PARAGRAPH.CENTER
        for run in notice_table.cell(0, 0).paragraphs[0].runs:
            run.font.bold = True
        notice_text = str(settings.get("proprietary_notice", "")).replace("<br/>", "\n")
        notice_table.cell(1, 0).text = notice_text

        document.add_paragraph()

    # ------------------------------------------------------------------
    def _add_table_of_contents(self, document, settings, OxmlElement, qn) -> None:
        document.add_paragraph("Table of Contents", style="Heading 1")
        toc_para = document.add_paragraph()
        toc_field = OxmlElement("w:fldSimple")
        toc_field.set(qn("w:instr"), 'TOC \\o "1-3" \\h \\z \\u')
        toc_para._p.append(toc_field)

        document.add_paragraph()
        document.add_paragraph("List of Figures", style="Heading 1")
        lof_para = document.add_paragraph()
        lof_field = OxmlElement("w:fldSimple")
        lof_field.set(qn("w:instr"), 'TOC \\h \\z \\c "Figure"')
        lof_para._p.append(lof_field)

        document.add_paragraph()
        document.add_paragraph("List of Tables", style="Heading 1")
        lot_para = document.add_paragraph()
        lot_field = OxmlElement("w:fldSimple")
        lot_field.set(qn("w:instr"), 'TOC \\h \\z \\c "Table"')
        lot_para._p.append(lot_field)

    # ------------------------------------------------------------------
    def _append_body_content(
        self,
        document,
        df: pd.DataFrame,
        settings,
        BeautifulSoup,
        WD_ALIGN_PARAGRAPH,
        Inches,
        table_alignment,
        OxmlElement,
        qn,
        RGBColor,
    ) -> None:
        section_col = self.data_manager.section_column_name
        add_horizontal_rule = getattr(self, "_add_horizontal_rule", None)

        def maybe_add_horizontal_rule() -> None:
            if callable(add_horizontal_rule):
                add_horizontal_rule(document, OxmlElement, qn)

        pending_requirement_rule = False

        for index, row in df.iterrows():
            global_index = int(row.get("_global_index", index)) if "_global_index" in row else index
            obj_type = str(row.get("Object Type", "")).strip().lower()
            section = str(row.get(section_col, "")).strip()
            text_value = str(row.get("Object Text", "")).strip()
            req_id = str(row.get("Requirement ID", "")).strip()
            attachment_type = str(row.get("Attachment Type", "")).strip().lower()
            attachment_data = str(row.get("Attachment Data", "")).strip()

            is_attachment = attachment_type in {"table", "image"} and bool(attachment_data)

            if obj_type.startswith("heading"):
                if pending_requirement_rule:
                    maybe_add_horizontal_rule()
                    pending_requirement_rule = False
                try:
                    level = max(1, min(int(obj_type.split()[-1]), 9))
                except ValueError:
                    level = 1
                heading_text = f"{section} {text_value}".strip() or text_value or section or "Heading"
                document.add_heading(heading_text, level=level)
                maybe_add_horizontal_rule()
                continue

            if attachment_type == "table" and attachment_data:
                self._add_table_from_html(
                    document,
                    attachment_data,
                    text_value,
                    BeautifulSoup,
                    WD_ALIGN_PARAGRAPH,
                    table_alignment,
                    RGBColor,
                    OxmlElement,
                    qn,
                )
                continue

            if attachment_type == "image" and attachment_data:
                self._add_image_from_payload(
                    document,
                    attachment_data,
                    text_value,
                    settings,
                    Inches,
                    WD_ALIGN_PARAGRAPH,
                    RGBColor,
                    OxmlElement,
                    qn,
                )
                continue

            if req_id:
                if pending_requirement_rule:
                    maybe_add_horizontal_rule()
                    pending_requirement_rule = False
                paragraph = document.add_paragraph()
                paragraph.alignment = WD_ALIGN_PARAGRAPH.LEFT
                label_run = paragraph.add_run("Requirement ID: ")
                label_run.bold = True
                value_run = paragraph.add_run(req_id)
                value_run.bold = False
                if text_value:
                    text_para = document.add_paragraph(text_value)
                    text_para.alignment = WD_ALIGN_PARAGRAPH.LEFT
                pending_requirement_rule = True
                continue

            if text_value:
                paragraph = document.add_paragraph(text_value)
                paragraph.alignment = WD_ALIGN_PARAGRAPH.LEFT

        if pending_requirement_rule:
            maybe_add_horizontal_rule()

    # ------------------------------------------------------------------


    def _add_table_from_html(
        self,
        document,
        html_table: str,
        caption: str,
        BeautifulSoup,
        WD_ALIGN_PARAGRAPH,
        table_alignment,
        RGBColor,
        OxmlElement,
        qn,
    ) -> None:
        soup = BeautifulSoup(html_table, "html.parser")
        rows = soup.find_all("tr")
        if not rows:
            return
        max_cols = max(len(row.find_all(["td", "th"])) for row in rows)
        table = document.add_table(rows=len(rows), cols=max_cols)
        table.style = "Table Grid"
        if table_alignment is not None:
            table.alignment = table_alignment

        for row_idx, row_tag in enumerate(rows):
            cells = row_tag.find_all(["td", "th"])
            for col_idx, cell in enumerate(cells):
                if col_idx >= max_cols:
                    break
                cell_text = cell.get_text(separator="\n").strip()
                table.cell(row_idx, col_idx).text = cell_text

        caption_text = caption.strip()
        caption_para = document.add_paragraph(style="Caption")
        caption_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
        label_run = caption_para.add_run("Table ")
        label_run.font.bold = False
        label_run.font.color.rgb = RGBColor(0, 0, 0)
        self._append_seq_field(caption_para, "Table", RGBColor, OxmlElement, qn)
        tail_text = f": {caption_text}" if caption_text else ""
        tail_run = caption_para.add_run(tail_text)
        tail_run.font.bold = False
        tail_run.font.color.rgb = RGBColor(0, 0, 0)

    def _add_image_from_payload(
        self,
        document,
        payload: str,
        caption: str,
        settings,
        Inches,
        WD_ALIGN_PARAGRAPH,
        RGBColor,
        OxmlElement,
        qn,
    ) -> None:
        try:
            data = json.loads(payload)
        except json.JSONDecodeError:
            data = {"data": payload, "mime": "image/png", "filename": "image"}

        raw_data = data.get("data", "")
        if not raw_data:
            return
        try:
            image_bytes = base64.b64decode(raw_data)
        except (ValueError, TypeError):
            return

        image_stream = io.BytesIO(image_bytes)
        paragraph = document.add_paragraph()
        paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
        run = paragraph.add_run()
        try:
            width = float(settings.get("export_image_width_inches", 5.5))
            run.add_picture(image_stream, width=Inches(width))
        except Exception:
            return

        caption_text = caption.strip() if caption else data.get("filename", "")
        caption_para = document.add_paragraph(style="Caption")
        caption_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
        label_run = caption_para.add_run("Figure ")
        label_run.font.bold = False
        label_run.font.color.rgb = RGBColor(0, 0, 0)
        self._append_seq_field(caption_para, "Figure", RGBColor, OxmlElement, qn)
        tail_text = f": {caption_text or 'Figure'}"
        tail_run = caption_para.add_run(tail_text)
        tail_run.font.bold = False
        tail_run.font.color.rgb = RGBColor(0, 0, 0)


    def _apply_watermark(self, document, text: str, parse_xml, nsdecls) -> None:
        safe_text = (text or "").strip()
        if not safe_text:
            return
        safe_text = html.escape(safe_text).replace('"', "'")
        section = document.sections[0]
        header = section.header
        ns_v = "{urn:schemas-microsoft-com:vml}"
        for shape in header._element.findall(f".//{ns_v}shape"):
            if "PowerPlusWaterMarkObject" in (shape.get("id") or ""):
                parent = shape.getparent()
                if parent is not None:
                    parent.remove(shape)
        for shapetype in header._element.findall(f".//{ns_v}shapetype"):
            if shapetype.get("id") == "_x0000_t136":
                parent = shapetype.getparent()
                if parent is not None:
                    parent.remove(shapetype)

        watermark_xml = (
            '<w:p xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" '
            'xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" '
            'xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:w10="urn:schemas-microsoft-com:office:word">'
            "<w:r><w:pict>"
            '<v:shapetype id="_x0000_t136" coordsize="21600,21600" o:spt="136" o:connecttype="custom" '
            'path="m@7,l@8,m@5,21600l@6,21600e" filled="f" stroked="f">'
            "<v:formulas>"
            "<v:f eqn=\"if lineDrawn pixelLineWidth 0\"/>"
            "<v:f eqn=\"sum @0 1 0\"/>"
            "<v:f eqn=\"sum 0 0 @1\"/>"
            "<v:f eqn=\"prod @2 1 2\"/>"
            "<v:f eqn=\"prod @3 21600 pixelWidth\"/>"
            "<v:f eqn=\"prod @3 21600 pixelHeight\"/>"
            "<v:f eqn=\"sum @0 0 1\"/>"
            "<v:f eqn=\"prod @6 1 2\"/>"
            "<v:f eqn=\"prod @7 21600 pixelWidth\"/>"
            "<v:f eqn=\"prod @7 21600 pixelHeight\"/>"
            "</v:formulas>"
            "<v:path o:extrusionok=\"f\" gradientshapeok=\"t\" o:connecttype=\"custom\" "
            'connectlocs="@5,0;@6,21600;@8,0;@9,21600"/>'
            "<o:lock v:ext=\"edit\" text=\"t\" shapetype=\"t\"/>"
            "</v:shapetype>"
            '<v:shape id="PowerPlusWaterMarkObject" o:spid="_x0000_s1025" type="#_x0000_t136" '
            'style="position:absolute;margin-left:0;margin-top:0;width:468pt;height:468pt;rotation:315;z-index:-251658240;visibility:visible;mso-wrap-edited:f" '
            'o:allowincell="f" fillcolor="gray" stroked="f">'
            '<v:fill opacity="0.1" />'
            f"<v:textpath style=\"font-family:'Calibri';font-size:48pt\" string=\"{safe_text}\"/>"
            "</v:shape>"
            "</w:pict></w:r></w:p>"
        )
        header._element.append(parse_xml(watermark_xml))

    def _append_seq_field(self, paragraph, label: str, RGBColor, OxmlElement, qn) -> None:
        run = paragraph.add_run()
        fld_char_begin = OxmlElement("w:fldChar")
        fld_char_begin.set(qn("w:fldCharType"), "begin")
        run._r.append(fld_char_begin)

        instr_text = OxmlElement("w:instrText")
        instr_text.text = f"SEQ {label} \\* ARABIC"
        run._r.append(instr_text)

        fld_char_separate = OxmlElement("w:fldChar")
        fld_char_separate.set(qn("w:fldCharType"), "separate")
        run._r.append(fld_char_separate)

        value_run = paragraph.add_run("1")
        fld_char_end = OxmlElement("w:fldChar")
        fld_char_end.set(qn("w:fldCharType"), "end")
        value_run._r.append(fld_char_end)

        for seq_run in (run, value_run):
            seq_run.font.bold = False
            seq_run.font.color.rgb = RGBColor(0, 0, 0)

    # ------------------------------------------------------------------
    def _add_horizontal_rule(self, document, OxmlElement, qn) -> None:
        paragraph = document.add_paragraph()
        p = paragraph._p
        pPr = p.get_or_add_pPr()
        pbdr = OxmlElement("w:pBdr")
        bottom = OxmlElement("w:bottom")
        bottom.set(qn("w:val"), "single")
        bottom.set(qn("w:sz"), "6")
        bottom.set(qn("w:space"), "1")
        bottom.set(qn("w:color"), "000000")
        pbdr.append(bottom)
        pPr.append(pbdr)

    def _clear_table_borders(self, table, OxmlElement, qn) -> None:
        tbl_pr = table._tbl.tblPr
        if tbl_pr is None:
            tbl_pr = OxmlElement("w:tblPr")
            table._tbl.tblPr = tbl_pr
        borders = tbl_pr.find(qn("w:tblBorders"))
        if borders is not None:
            tbl_pr.remove(borders)

    # ------------------------------------------------------------------
    def _insert_logo(self, paragraph, path: str, Inches) -> None:
        if not path:
            return
        logo_path = Path(path)
        if not logo_path.exists():
            return
        try:
            run = paragraph.add_run()
            run.add_picture(str(logo_path), width=Inches(2.3))
        except Exception:
            paragraph.add_run("")

    # ------------------------------------------------------------------
    def navigate_to_requirement(
        self, requirement_id: str, source: Optional[str] = None
    ) -> None:
        target = (requirement_id or "").strip()
        if not target:
            return
        df = self.data_manager.dataframe
        if df.empty:
            self.log_console(f"No data loaded to locate: {target}")
            return
        lowered = target.lower()
        match_row: int | None = None
        match_source = None
        for idx, row in df.iterrows():
            for column in ("Requirement ID", "Up Trace"):
                value = str(row.get(column, "")).strip().lower()
                if value == lowered:
                    match_row = idx
                    match_source = str(row.get("SourceFile", "")).strip() or "Manual"
                    break
            if match_row is not None:
                break
        if match_row is None:
            self.log_console(f"Could not locate requirement: {target}")
            return
        row_source_type = (
            str(df.at[match_row, "SourceType"]).strip().lower()
            if "SourceType" in df.columns
            else ""
        )
        selected_source = source or match_source or "Manual"
        if row_source_type == "excel" and "Excel" in self._tab_source_types:
            selected_source = "Excel"
        self._select_source_tab(selected_source)
        self.view_stack.setCurrentWidget(self.table_tabs)
        self._select_global_row(selected_source, match_row)
        table = self._tab_tables.get(selected_source)
        if table is not None:
            table.setFocus()
        self.log_console(f"Navigated to requirement: {target}")

    # ------------------------------------------------------------------
    def _switch_to_trace_view(self, highlight: Optional[str] = None) -> bool:
        df = self.data_manager.to_trace_dataframe()
        if df.empty:
            QMessageBox.information(self, "Empty", "No data available.")
            return False
        df = df.copy()
        df["_row_index"] = range(len(df))
        self.trace_view.load_data(df)
        self.view_stack.setCurrentWidget(self.trace_view)
        self.log_console("Switched to Traceability Matrix view.")
        if highlight:
            def focus() -> None:
                if self.trace_view.highlight_requirement(highlight):
                    self.log_console(f"Focused trace entry: {highlight}")
                else:
                    self.log_console(f"Trace entry not found: {highlight}")

            QTimer.singleShot(0, focus)
        return True

    def search_requirements(self) -> None:
        """Search visible content (requirement, table, or text) in the active tab only."""
        query = self.search_input.text().strip().lower()
        if not query:
            QMessageBox.information(self, "Search", "Enter text to search.")
            return

        df = self.data_manager.dataframe
        if df.empty:
            QMessageBox.information(self, "Search", "No data loaded.")
            return

        # Detect current tab (SourceFile)
        current_widget = self.table_tabs.currentWidget()
        current_source = None
        if current_widget and hasattr(current_widget, "objectName"):
            current_source = current_widget.objectName()

        # Filter dataframe by source (tab)
        if current_source and "SourceFile" in df.columns:
            tab_df = df[df["SourceFile"].astype(str).str.lower() == current_source.lower()]
        else:
            tab_df = df

        # Search across all relevant fields (ignore image binary data)
        search_cols = [
            "Object Type",
            "Requirement ID",
            "Object Text",
            "Attachment Data",  # for tables
        ]
        matches = tab_df[
            tab_df.apply(
                lambda row: any(
                    query in str(row.get(col, "")).lower()
                    for col in search_cols
                    if not str(row.get("Attachment Type", "")).lower().startswith("image")
                ),
                axis=1,
            )
        ]

        if matches.empty:
            QMessageBox.information(self, "Search", f"No matches found for '{query}'.")
            return

        total = len(matches)
        first_idx = matches.index[0]
        LOGGER.info("Search found %d matches for '%s' in tab '%s'.", total, query, current_source or "All")
        self.log_console(f"Found {total} match(es) for '{query}'.")

        # Highlight first match in current table view
        if hasattr(current_widget, "setCurrentCell"):
            self._highlight_table_match(current_widget, matches, first_idx, query)

    def _highlight_table_match(self, table_widget, matches_df, first_idx, query):
        """Scroll to the first matching cell in the visible QTableWidget."""
        if table_widget.rowCount() == 0:
            return

        first_match = matches_df.iloc[0]
        rid = str(first_match.get("Requirement ID", "")).strip()
        text_snippet = str(first_match.get("Object Text", "")).strip()

        for row in range(table_widget.rowCount()):
            for col in range(table_widget.columnCount()):
                item = table_widget.item(row, col)
                if not item:
                    continue
                cell_text = item.text().lower()
                if query in cell_text:
                    table_widget.selectRow(row)
                    table_widget.scrollToItem(item)
                    return
                
    def run_search(self) -> None:
        """Perform search in the current tab and populate result list."""
        query = self.search_input.text().strip().lower()
        self.search_results.clear()
        if not query:
            QMessageBox.information(self, "Search", "Enter text to search.")
            return

        df = self.data_manager.dataframe
        if df.empty:
            QMessageBox.information(self, "Search", "No data loaded.")
            return

        # Determine which tab (source file) is currently active
        current_widget = self.table_tabs.currentWidget()
        current_source = None
        if current_widget and hasattr(current_widget, "objectName"):
            current_source = current_widget.objectName()

        # Filter by current tab source
        if current_source and "SourceFile" in df.columns:
            tab_df = df[df["SourceFile"].astype(str).str.lower() == current_source.lower()]
        else:
            tab_df = df

        # Search across text-based columns (ignore image data)
        search_cols = ["Requirement ID", "Object Text", "Attachment Data", "Object Type"]
        matches = tab_df[
            tab_df.apply(
                lambda row: any(
                    query in str(row.get(col, "")).lower()
                    for col in search_cols
                    if not str(row.get("Attachment Type", "")).lower().startswith("image")
                ),
                axis=1,
            )
        ]

        if matches.empty:
            QMessageBox.information(self, "Search", f"No matches found for '{query}'.")
            return

        self.search_matches = matches
        self.search_index = 0

        # Populate result list
        for _, row in matches.iterrows():
            rid = row.get("Requirement ID", "")
            obj_type = row.get("Object Type", "")
            snippet = row.get("Object Text", "")[:120].replace("\n", " ")
            item_text = f"[{obj_type}] {rid or ''}: {snippet}"
            item = QListWidgetItem(item_text)
            self.search_results.addItem(item)

        total = len(matches)
        LOGGER.info("Found %d matches for '%s' in current tab.", total, query)
        self.log_console(f"Found {total} match(es) for '{query}' in this tab.")

        self._toggle_left_panel(1)

        if total > 0:
            self.highlight_match_at_index(0)

        # ---------------- Excel-like header menu & helpers ----------------
    def _open_header_menu_shortcut(self) -> None:
        """Alt+Down at window scope → open current table's header menu for the active column."""
        table = self._current_table()
        if not table:
            return
        self._open_table_header_menu(table)

    def _open_table_header_menu(self, table: QTableWidget) -> None:
        col = table.currentColumn()
        if col < 0:
            col = 0
        self._on_table_header_clicked(table, col)

    def _on_table_header_clicked(self, table: QTableWidget, index: int) -> None:
        """Excel-style drop-down: search + multi-select filter + sort on the current table."""
        if index < 0:
            return
        source = str(table.property("source") or "")
        cols = [table.horizontalHeaderItem(i).text() for i in range(table.columnCount())]
        if not (0 <= index < len(cols)):
            return
        col_name = cols[index]

        # Use the raw (unfiltered) data for this source to build the distinct list
        df_source = self._get_dataframe_for_source(source, raw=True)
        if df_source.empty or col_name not in df_source.columns:
            return
        # Distinct values as strings
        values = sorted({str(v) for v in df_source[col_name].fillna("").astype(str).tolist()})

        menu = QMenu(self)
        # search box
        search = QLineEdit()
        search.setPlaceholderText("Search...")
        act_search = QWidgetAction(menu)
        act_search.setDefaultWidget(search)
        menu.addAction(act_search)
        menu.addSeparator()

        # scrollable list of checkboxes
        scroll = QScrollArea()
        scroll.setMinimumWidth(320)
        scroll.setMaximumHeight(380)
        scroll.setWidgetResizable(True)
        container = QWidget()
        vbox = QVBoxLayout(container)
        vbox.setContentsMargins(6, 6, 6, 6)
        vbox.setSpacing(4)

        selected_current = (self._table_filters.get(source, {}) or {}).get(index, set(values)) or set(values)
        checkboxes: list[QCheckBox] = []
        for val in values:
            cb = QCheckBox(val)
            cb.setChecked(val in selected_current)
            vbox.addWidget(cb)
            checkboxes.append(cb)
        scroll.setWidget(container)
        act_scroll = QWidgetAction(menu)
        act_scroll.setDefaultWidget(scroll)
        menu.addAction(act_scroll)
        menu.addSeparator()

        # action row
        apply_btn = QPushButton("Apply")
        act_apply = QWidgetAction(menu)
        act_apply.setDefaultWidget(apply_btn)
        menu.addAction(act_apply)
        clear_action = menu.addAction("Clear Filter")
        show_all_action = menu.addAction("Show All")
        menu.addSeparator()
        sort_asc = menu.addAction("Sort Ascending")
        sort_desc = menu.addAction("Sort Descending")
        clear_sort = menu.addAction("Clear Sort")

        def on_search(text: str) -> None:
            t = text.lower()
            for cb in checkboxes:
                cb.setVisible(t in cb.text().lower())
        search.textChanged.connect(on_search)

        def on_apply() -> None:
            selected = {cb.text() for cb in checkboxes if cb.isChecked()}
            f = self._table_filters.setdefault(source, {})
            if len(selected) == len(checkboxes):
                # no filter (all selected)
                f.pop(index, None)
            else:
                f[index] = selected
            # repaint only this tab
            self.populate_table()
            # reselect this tab after repopulate
            self._select_source_tab(source)
            menu.close()
        apply_btn.clicked.connect(on_apply)

        def on_clear() -> None:
            self._table_filters.setdefault(source, {}).pop(index, None)
            self.populate_table()
            self._select_source_tab(source)
            menu.close()
        clear_action.triggered.connect(on_clear)

        def on_show_all() -> None:
            self._table_filters.pop(source, None)
            self.populate_table()
            self._select_source_tab(source)
            menu.close()
        show_all_action.triggered.connect(on_show_all)

        def do_sort(ascending: bool | None) -> None:
            if ascending is None:
                self._table_sort.pop(source, None)
            else:
                self._table_sort[source] = (index, bool(ascending))
            self.populate_table()
            self._select_source_tab(source)
            menu.close()
        sort_asc.triggered.connect(lambda: do_sort(True))
        sort_desc.triggered.connect(lambda: do_sort(False))
        clear_sort.triggered.connect(lambda: do_sort(None))

        header = table.horizontalHeader()
        x = header.sectionPosition(index)
        y = header.height()
        menu.exec(table.mapToGlobal(QPoint(x + 12, y + 20)))

    def _apply_table_filters(self, source: str, group: pd.DataFrame, base_columns: list[str]) -> pd.DataFrame:
        """Apply saved filters for a source on its group before painting."""
        if not source or group.empty:
            return group
        filters = self._table_filters.get(source)
        if not filters:
            return group
        df = group.copy()
        for col_idx, selected in filters.items():
            if not (0 <= col_idx < len(base_columns)):
                continue
            col_name = base_columns[col_idx]
            sel = set(map(str, selected))
            df = df[df[col_name].fillna("").astype(str).isin(sel)]
            if df.empty:
                break
        return df

    def _apply_table_sort(self, source: str, group: pd.DataFrame, base_columns: list[str]) -> pd.DataFrame:
        order = self._table_sort.get(source)
        if not order or group.empty:
            return group
        col_idx, asc = order
        if not (0 <= col_idx < len(base_columns)):
            return group
        col_name = base_columns[col_idx]
        try:
            return group.sort_values(by=col_name, ascending=asc, kind="mergesort")
        except Exception:
            return group

    # ---------------- Object Type drop-down & heading shortcuts ----------------
    def _set_object_type_cell(self, table: QTableWidget, row: int, df_index: int, current_value: str) -> None:
        """Place a QComboBox in the 'Object Type' column with allowed values."""
        combo = QComboBox(table)
        combo.addItems(self._object_types)
        # Pick the closest match; default to original string if it's custom
        try:
            idx = self._object_types.index(current_value) if current_value in self._object_types else -1
        except Exception:
            idx = -1
        if idx >= 0:
            combo.setCurrentIndex(idx)
        else:
            combo.insertItem(0, current_value or "")
            combo.setCurrentIndex(0)
        combo.currentTextChanged.connect(lambda text, r=df_index: self._on_object_type_changed(r, text))
        table.setCellWidget(row, self.data_manager.visible_columns.index("Object Type"), combo)

    def _on_object_type_changed(self, df_index: int, new_value: str) -> None:
        """Update the model when the Object Type combo changes, then refresh numbering/UI."""
        try:
            self.data_manager.update_cell(int(df_index), "Object Type", (new_value or "").strip())
        except RequirementDataError as exc:
            QMessageBox.warning(self, "Edit Error", str(exc))
            return
        refreshed = self.data_manager.refresh_dataframe()
        self._undo_stack.append(refreshed.copy())
        self.populate_table()

    def _set_heading_level_shortcut(self, level: int) -> None:
        """Alt+1/2/3 → set current row's object type to heading level."""
        table = self._current_table()
        if not table:
            return
        row = table.currentRow()
        if row < 0:
            return
        # Find Object Type column in the visible headers
        cols = [table.horizontalHeaderItem(i).text() for i in range(table.columnCount())]
        if "Object Type" not in cols:
            return
        col = cols.index("Object Type")
        widget = table.cellWidget(row, col)
        if isinstance(widget, QComboBox):
            widget.setCurrentText(f"Heading {level}")
        else:
            item = table.item(row, col)
            if item:
                item.setText(f"Heading {level}")
                self.on_table_cell_changed(item)

    def _focus_excel_tab(self) -> None:
        """Ctrl+E → focus the Excel (grid) tab and show the grid view."""
        # Prefer an explicit 'Excel' tab if present
        for idx in range(self.table_tabs.count()):
            w = self.table_tabs.widget(idx)
            if isinstance(w, QTableWidget) and str(w.property("source") or "") == "Excel":
                self.table_tabs.setCurrentIndex(idx)
                break
        self.view_stack.setCurrentWidget(self.table_tabs)
        self.log_console("Excel preview focused.")


    def highlight_match_at_index(self, index: int, direction: str = "next"):
        """Jump both the table and the preview to the indexed match."""
        if not hasattr(self, "search_matches") or self.search_matches is None or self.search_matches.empty:
            return
        if index < 0 or index >= len(self.search_matches):
            return

        match_row = self.search_matches.iloc[index]
        # ← This is the original DataFrame index (global row id), perfect for anchors.
        global_index = int(match_row.name)

        rid = str(match_row.get("Requirement ID", "")).strip()
        text = str(match_row.get("Object Text", "")).strip()
        snippet = text[:120].replace("\n", " ")
        query_text = self.search_input.text().strip().lower()

        # --- Select in the current QTableWidget (right pane) ---
        current_table = self.table_tabs.currentWidget()
        if hasattr(current_table, "rowCount") and current_table.rowCount() > 0:
            # Try to select the table row that shows this global index
            # (your populate_table stores df index in UserRole for every item)
            found = False
            for r in range(current_table.rowCount()):
                item0 = current_table.item(r, 0)
                if not item0:
                    continue
                df_idx = item0.data(Qt.ItemDataRole.UserRole)
                if df_idx is None:
                    continue
                if int(df_idx) == global_index:
                    current_table.setCurrentCell(r, 0)
                    current_table.selectRow(r)
                    current_table.scrollToItem(item0, QTableWidget.ScrollHint.PositionAtCenter)
                    found = True
                    break

            # Fallback by text if for some reason the df index isn't present
            if not found:
                for r in range(current_table.rowCount()):
                    for c in range(current_table.columnCount()):
                        it = current_table.item(r, c)
                        if not it:
                            continue
                        cell = it.text().lower()
                        if (rid and rid.lower() in cell) or (query_text and query_text in cell):
                            current_table.setCurrentCell(r, c)
                            current_table.selectRow(r)
                            current_table.scrollToItem(it, QTableWidget.ScrollHint.PositionAtCenter)
                            found = True
                            break
                    if found:
                        break

        # --- Jump the Word preview (center/top pane) by anchor ---
        # Use the anchor we render: id="row-<global_index>"
        self._scroll_preview_to_row(global_index, [rid, text, snippet, self.search_input.text()])

        self.log_console(f"Moved to match #{index + 1}: {rid or snippet[:40]}")

    def save_excel_with_images(self) -> None:
        """
        Export a single-sheet Excel with:
        - 1 row per Requirement
        - Requirement Content in one cell
        - Referenced Tables/Figures
        - Thumbnails embedded in cells for Image Path(s)
        """
        try:
            from openpyxl import Workbook
            from openpyxl.drawing.image import Image as XLImage
            from openpyxl.utils import get_column_letter
            from PIL import Image as PILImage
            import io, os
        except Exception as exc:
            QMessageBox.critical(self, "Dependency Error",
                "Export requires 'openpyxl' and 'Pillow'.\n" + str(exc))
            return

        # Build grouped export from the full dataset (across tabs)
        df_export = self.data_manager.build_grouped_export()
        if df_export.empty:
            QMessageBox.information(self, "Empty", "No requirements to export.")
            return

        file_name, _ = QFileDialog.getSaveFileName(
            self, "Save Excel (with images)", "", "Excel Files (*.xlsx)"
        )
        if not file_name:
            return
        if not file_name.lower().endswith(".xlsx"):
            file_name += ".xlsx"

        wb = Workbook()
        ws = wb.active
        ws.title = "Requirements"

        headers = [
            "Requirement ID",
            "Requirement Content",
            "Referenced Tables",
            "Referenced Figures",
            "Image Path(s)"
        ]
        ws.append(headers)

        # basic column widths
        widths = [22, 80, 28, 28, 24]
        for i, w in enumerate(widths, start=1):
            ws.column_dimensions[get_column_letter(i)].width = w

        # Row-by-row copy + embed image thumbnails
        thumb_max_w, thumb_max_h = 140, 100   # pixels (roughly maps to Excel cell size)
        for _, row in df_export.iterrows():
            ws.append([
                row.get("Requirement ID", ""),
                row.get("Requirement Content", ""),
                row.get("Referenced Tables", ""),
                row.get("Referenced Figures", ""),
                row.get("Image Path(s)", ""),
            ])
            excel_row = ws.max_row

            # Embed first image as thumbnail in the last column cell
            img_paths = [p.strip() for p in str(row.get("Image Path(s)", "")).split(",") if p.strip()]
            if not img_paths:
                continue
            first = img_paths[0]
            if not Path(first).exists():
                continue

            try:
                with PILImage.open(first) as im:
                    im.thumbnail((thumb_max_w, thumb_max_h))  # in-place thumbnail
                    buf = io.BytesIO()
                    im.save(buf, format="PNG")
                    buf.seek(0)
                    xl_img = XLImage(buf)
                    # Anchor to the "Image Path(s)" column cell
                    anchor_cell = f"E{excel_row}"  # column E = 5th col
                    ws.add_image(xl_img, anchor_cell)
                    # Increase row height a bit to show the thumb
                    ws.row_dimensions[excel_row].height = 80
            except Exception:
                # ignore bad images silently; paths are still present in cell
                pass

        try:
            wb.save(file_name)
        except Exception as exc:
            QMessageBox.critical(self, "Save Error", f"Failed to save Excel: {exc}")
            return

        self.log_console(f"Excel saved with embedded thumbnails: {file_name}")
        QMessageBox.information(self, "Saved", f"✅ Excel saved:\n{file_name}")
    
        
    def find_next_match(self):
        if not hasattr(self, "search_matches") or self.search_matches is None or self.search_matches.empty:
            self.run_search()
            return
        self.search_index = (self.search_index + 1) % len(self.search_matches)
        self.highlight_match_at_index(self.search_index, direction="next")
        self.search_results.setCurrentRow(self.search_index)

    def find_previous_match(self):
        if not hasattr(self, "search_matches") or self.search_matches is None or self.search_matches.empty:
            self.run_search()
            return
        self.search_index = (self.search_index - 1) % len(self.search_matches)
        self.highlight_match_at_index(self.search_index, direction="prev")
        self.search_results.setCurrentRow(self.search_index)



    def navigate_to_search_result(self, item):
        """Jump to the clicked match in the results list."""
        index = self.search_results.row(item)
        self.search_index = index
        self.highlight_match_at_index(index)

    def clear_search_results(self):
        """Clear all search matches and results."""
        self.search_results.clear()
        self.search_matches = None
        self.search_index = 0
        self.log_console("Cleared search results.")

    def _toggle_left_panel(self, index: int):
        """Switch between Navigation and Search Results panel."""
        self.left_stack.setCurrentIndex(index)
        self.btn_nav_view.setChecked(index == 0)
        self.btn_search_view.setChecked(index == 1)
        if index == 0:
            self.log_console("Switched to Navigation view.")
        else:
            self.log_console("Switched to Search Results view.")
    # --- Project persistence helpers (drop inside MainWindow) ---

    def _ensure_project_paths(self):
        """Guarantee project folders and metadata path exist."""
        if not getattr(self, "project_path", None):
            self.project_path = (self._projects_root() / (self.project_name or "Untitled")).resolve()
        self.project_path.mkdir(parents=True, exist_ok=True)
        self.project_meta = self.project_path / "project.json"

    def _copy_into_project(self, paths: list[str]) -> list[str]:
        """Copy external files into the project folder; return local absolute paths."""
        self._ensure_project_paths()
        out: list[str] = []
        for p in paths:
            src = Path(p)
            if not src.exists():
                continue
            dst = self.project_path / src.name
            if str(src.resolve()) != str(dst.resolve()):
                try:
                    shutil.copy2(src, dst)
                except Exception as e:
                    self.log_console(f"Copy failed for {src.name}: {e}")
                    continue
            out.append(str(dst))
        return out

    def _save_project_metadata(self, *, excel_files=None, word_files=None, word_pattern=None, header_profiles=None):
        """Merge and write project.json (this version belongs to MainWindow)."""
        self._ensure_project_paths()
        data = {}
        if self.project_meta.exists():
            try:
                data = json.loads(self.project_meta.read_text(encoding="utf-8"))
            except Exception:
                data = {}
        data["name"] = self.project_name
        data["last_modified"] = datetime.datetime.now().isoformat()

        # store basenames to keep metadata portable
        if excel_files is not None:
            data["excel_files"] = [Path(p).name for p in excel_files]
        if word_files is not None:
            data["word_files"] = [Path(p).name for p in word_files]
        if word_pattern is not None:
            data["word_pattern"] = word_pattern
        if header_profiles is not None:
            data["header_profiles"] = header_profiles

        self.project_meta.write_text(json.dumps(data, indent=4), encoding="utf-8")

    def _save_project_state(self):
        """Persist the working DataFrame + header profiles."""
        try:
            self._ensure_project_paths()
            df_path = (self.project_path / "data.json")
            # Use orient='table' so index & schema are preserved
            self.data_manager.dataframe.to_json(df_path, orient="table")
            # also keep header profiles together with project.json
            self._save_project_metadata(header_profiles=self.header_profiles)
            self.log_console("Project state saved.")
        except Exception as e:
            self.log_console(f"Save state failed: {e}")

    def _load_project_state(self) -> bool:
        """Try to load a previously-saved dataframe from data.json."""
        try:
            self._ensure_project_paths()
            df_path = self.project_path / "data.json"
            if not df_path.exists():
                return False
            df = pd.read_json(df_path, orient="table")
            # Let your manager finalize anything it needs
            self.data_manager.dataframe = self.data_manager.finalize_dataframe(df)
            self.populate_table()
            self.log_console("Restored project from saved state.")
            return True
        except Exception as e:
            self.log_console(f"State restore failed: {e}")
            return False
        
    # >>> ADD in MainWindow class
    def _active_excel_tab(self) -> 'ExcelTab | None':
        w = self.table_tabs.currentWidget()
        return w if isinstance(w, ExcelTab) else None

    def add_excel_tab_from_files(self, files: list[str]) -> None:
        """Create a new tab for the selected/dropped Excel files and load them."""
        if not files:
            return
        tab = ExcelTab(self)
        tab.load_files(files)
        # Name the tab with file base names (trim if too long)
        base = ", ".join([os.path.basename(f) for f in files])
        if len(base) > 40:
            base = base[:37] + "..."
        self.table_tabs.addTab(tab, base)
        self.table_tabs.setCurrentWidget(tab)

    def on_click_load_excel(self):
        """Hook this to your 'Load Excel' button/menu if you have one."""
        files, _ = QFileDialog.getOpenFileNames(self, "Select Excel files", "", "Excel Files (*.xlsx *.xls *.xlsm)")
        if files:
            self.add_excel_tab_from_files(files)

    # Drag & Drop: accept Excel files anywhere on main window
    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            for url in event.mimeData().urls():
                if url.isLocalFile() and url.toLocalFile().lower().endswith((".xlsx", ".xls", ".xlsm")):
                    event.acceptProposedAction()
                    return
        event.ignore()

    def dropEvent(self, event):
        files = [
            url.toLocalFile() for url in event.mimeData().urls()
            if url.isLocalFile() and url.toLocalFile().lower().endswith((".xlsx", ".xls", ".xlsm"))
        ]
        if files:
            self.add_excel_tab_from_files(files)
        else:
            event.ignore()



class HeaderSettingsDialog(QDialog):
    """Modal dialog for editing document header, footer, and export options."""

    def __init__(self, parent: QWidget, settings: Dict[str, object]):
        super().__init__(parent)
        self.setWindowTitle("Header Details")
        self._settings = settings

        layout = QVBoxLayout(self)
        form = QFormLayout()

        self.title_edit = QLineEdit(str(settings.get("document_title", "")))
        form.addRow("Document Title", self.title_edit)

        self.doc_number_edit = QLineEdit(str(settings.get("document_number", "")))
        form.addRow("Document Number", self.doc_number_edit)

        self.revision_edit = QLineEdit(str(settings.get("revision", "")))
        form.addRow("Revision", self.revision_edit)

        self.author_name_edit = QLineEdit(str(settings.get("author_name", "")))
        form.addRow("Author Name", self.author_name_edit)
        self.author_title_edit = QLineEdit(str(settings.get("author_title", "")))
        form.addRow("Author Title", self.author_title_edit)

        self.reviewer_name_edit = QLineEdit(str(settings.get("reviewer_name", "")))
        form.addRow("Reviewer Name", self.reviewer_name_edit)
        self.reviewer_title_edit = QLineEdit(str(settings.get("reviewer_title", "")))
        form.addRow("Reviewer Title", self.reviewer_title_edit)

        self.qa_name_edit = QLineEdit(str(settings.get("qa_name", "")))
        form.addRow("QA Name", self.qa_name_edit)
        self.qa_title_edit = QLineEdit(str(settings.get("qa_title", "")))
        form.addRow("QA Title", self.qa_title_edit)

        self.config_name_edit = QLineEdit(str(settings.get("config_manager_name", "")))
        form.addRow("Configuration Manager Name", self.config_name_edit)
        self.config_title_edit = QLineEdit(
            str(settings.get("config_manager_title", ""))
        )
        form.addRow("Configuration Manager Title", self.config_title_edit)

        logo_left_widget, self.logo_left_edit = self._create_path_selector(
            str(settings.get("logo_left_path", ""))
        )
        form.addRow("Howell Logo", logo_left_widget)

        logo_right_widget, self.logo_right_edit = self._create_path_selector(
            str(settings.get("logo_right_path", ""))
        )
        form.addRow("Mach Logo", logo_right_widget)

        self.preview_spin = QSpinBox()
        self.preview_spin.setRange(10, 100)
        self.preview_spin.setSuffix(" %")
        self.preview_spin.setValue(int(settings.get("preview_image_width_percent", 80)))
        form.addRow("Preview Image Width", self.preview_spin)

        self.export_spin = QDoubleSpinBox()
        self.export_spin.setRange(1.0, 10.0)
        self.export_spin.setSingleStep(0.1)
        self.export_spin.setSuffix(' in')
        self.export_spin.setValue(float(settings.get("export_image_width_inches", 5.5)))
        form.addRow("Export Image Width", self.export_spin)

        self.watermark_edit = QLineEdit(str(settings.get("watermark_text", "")))
        form.addRow("Watermark Text", self.watermark_edit)

        self.address_howell_edit = QPlainTextEdit(
            str(settings.get("address_howell", "")).replace("<br/>", "\n")
        )
        form.addRow("Howell Address", self.address_howell_edit)

        self.address_mach_edit = QPlainTextEdit(
            str(settings.get("address_mach", "")).replace("<br/>", "\n")
        )
        form.addRow("Mach Address", self.address_mach_edit)

        self.notice_edit = QPlainTextEdit(
            str(settings.get("proprietary_notice", "")).replace("<br/>", "\n")
        )
        form.addRow("Proprietary Notice", self.notice_edit)

        self.copyright_edit = QLineEdit(str(settings.get("copyright_notice", "")))
        form.addRow("Copyright Notice", self.copyright_edit)

        layout.addLayout(form)

        button_box = QDialogButtonBox(
        QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        # New: Clear-all button to reset header fields for a fresh document
        self.clear_btn = QPushButton("Clear All")
        button_box.addButton(self.clear_btn, QDialogButtonBox.ButtonRole.ResetRole)
        self.clear_btn.setToolTip("Reset every field to empty for a new document heading.")
        self.clear_btn.clicked.connect(self._clear_all_fields)


        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)

    def _create_path_selector(self, initial: str) -> tuple[QWidget, QLineEdit]:
        container = QWidget(self)
        h_layout = QHBoxLayout(container)
        h_layout.setContentsMargins(0, 0, 0, 0)
        line_edit = QLineEdit(initial)
        browse_btn = QPushButton("Browse")
        browse_btn.clicked.connect(lambda: self._browse_for_logo(line_edit))
        h_layout.addWidget(line_edit)
        h_layout.addWidget(browse_btn)
        return container, line_edit

    def _browse_for_logo(self, line_edit: QLineEdit) -> None:
        path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Logo",
            "",
            "Image Files (*.png *.jpg *.jpeg *.bmp *.gif *.tif *.tiff)",
        )
        if path:
            line_edit.setText(path)
    
    def _clear_all_fields(self) -> None:
        """Reset all fields to an empty state suitable for a new document heading."""
        # Text fields
        for w in (
            self.title_edit,
            self.doc_number_edit,
            self.revision_edit,
            self.author_name_edit,
            self.author_title_edit,
            self.reviewer_name_edit,
            self.reviewer_title_edit,
            self.qa_name_edit,
            self.qa_title_edit,
            self.config_name_edit,
            self.config_title_edit,
            self.logo_left_edit,
            self.logo_right_edit,
            self.watermark_edit,
            self.copyright_edit,
        ):
            w.clear()
        # Multiline fields
        self.address_howell_edit.clear()
        self.address_mach_edit.clear()
        self.notice_edit.clear()
        # Numeric fields (spin boxes cannot be blank; keep sane defaults)
        self.preview_spin.setValue(80)
        self.export_spin.setValue(5.5)

    def values(self) -> Dict[str, object]:
        return {
            "document_title": self.title_edit.text().strip(),
            "document_number": self.doc_number_edit.text().strip(),
            "revision": self.revision_edit.text().strip(),
            "author_name": self.author_name_edit.text().strip(),
            "author_title": self.author_title_edit.text().strip(),
            "reviewer_name": self.reviewer_name_edit.text().strip(),
            "reviewer_title": self.reviewer_title_edit.text().strip(),
            "qa_name": self.qa_name_edit.text().strip(),
            "qa_title": self.qa_title_edit.text().strip(),
            "config_manager_name": self.config_name_edit.text().strip(),
            "config_manager_title": self.config_title_edit.text().strip(),
            "logo_left_path": self.logo_left_edit.text().strip(),
            "logo_right_path": self.logo_right_edit.text().strip(),
            "preview_image_width_percent": int(self.preview_spin.value()),
            "export_image_width_inches": float(self.export_spin.value()),
            "watermark_text": self.watermark_edit.text().strip(),
            "address_howell": self.address_howell_edit.toPlainText()
            .strip()
            .replace("\n", "<br/>"),
            "address_mach": self.address_mach_edit.toPlainText()
            .strip()
            .replace("\n", "<br/>"),
            "proprietary_notice": self.notice_edit.toPlainText()
            .strip()
            .replace("\n", "<br/>"),
            "copyright_notice": self.copyright_edit.text().strip(),
        }


def run_app() -> None:
    """Entry point used by scripts to launch the GUI."""
    import sys

    logging.basicConfig(level=logging.INFO)
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())